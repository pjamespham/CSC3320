GREP(1)                          General Commands Manual                         GREP(1)



NAME
       grep, egrep, fgrep - print lines matching a pattern

SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]

DESCRIPTION
       grep  searches the named input FILEs (or standard input if no files are named, or
       if a single hyphen-minus (-) is given as file name) for lines containing a  match
       to the given PATTERN.  By default, grep prints the matching lines.

       In  addition,  two  variant programs egrep and fgrep are available.  egrep is the
       same as grep -E.  fgrep is the same as  grep -F.   Direct  invocation  as  either
       egrep  or  fgrep  is deprecated, but is provided to allow historical applications
       that rely on them to run unmodified.

OPTIONS
   Generic Program Information
       --help Print a usage message briefly summarizing these command-line  options  and
              the bug-reporting address, then exit.

       -V, --version
              Print  the  version  number  of  grep to the standard output stream.  This
              version number should be included in all bug reports (see below).

   Matcher Selection
       -E, --extended-regexp
              Interpret PATTERN as an extended regular expression (ERE, see below).  (-E
              is specified by POSIX.)

       -F, --fixed-strings, --fixed-regexp
              Interpret  PATTERN  as a list of fixed strings, separated by newlines, any
              of which is to be matched.  (-F is specified by POSIX,  --fixed-regexp  is
              an obsoleted alias, please do not use it in new scripts.)

       -G, --basic-regexp
              Interpret PATTERN as a basic regular expression (BRE, see below).  This is
              the default.

       -P, --perl-regexp
              Interpret  PATTERN  as  a  Perl  regular  expression.   This   is   highly
              experimental and grep -P may warn of unimplemented features.

   Matching Control
       -e PATTERN, --regexp=PATTERN
              Use  PATTERN  as the pattern.  This can be used to specify multiple search
              patterns, or to protect a pattern beginning with a  hyphen  (-).   (-e  is
              specified by POSIX.)

       -f FILE, --file=FILE
              Obtain  patterns  from  FILE,  one per line.  The empty file contains zero
              patterns, and therefore matches nothing.  (-f is specified by POSIX.)

       -i, --ignore-case
              Ignore case distinctions in both the PATTERN and the input files.  (-i  is
              specified by POSIX.)

       -v, --invert-match
              Invert  the  sense  of  matching,  to  select  non-matching lines.  (-v is
              specified by POSIX.)

       -w, --word-regexp
              Select only those lines containing matches that  form  whole  words.   The
              test is that the matching substring must either be at the beginning of the
              line, or preceded by a non-word constituent character.  Similarly, it must
              be  either  at  the  end of the line or followed by a non-word constituent
              character.  Word-constituent  characters  are  letters,  digits,  and  the
              underscore.

       -x, --line-regexp
              Select  only  those  matches  that  exactly  match the whole line.  (-x is
              specified by POSIX.)

       -y     Obsolete synonym for -i.

   General Output Control
       -c, --count
              Suppress normal output; instead print a count of matching lines  for  each
              input  file.   With  the -v, --invert-match option (see below), count non-
              matching lines.  (-c is specified by POSIX.)

       --color[=WHEN], --colour[=WHEN]
              Surround the matched (non-empty) strings, matching lines,  context  lines,
              file  names,  line  numbers,  byte offsets, and separators (for fields and
              groups of context lines) with escape sequences to display them in color on
              the  terminal.   The  colors  are  defined  by  the  environment  variable
              GREP_COLORS.  The deprecated  environment  variable  GREP_COLOR  is  still
              supported, but its setting does not have priority.  WHEN is never, always,
              or auto.

       -L, --files-without-match
              Suppress normal output; instead print the name of  each  input  file  from
              which  no output would normally have been printed.  The scanning will stop
              on the first match.

       -l, --files-with-matches
              Suppress normal output; instead print the name of  each  input  file  from
              which  output would normally have been printed.  The scanning will stop on
              the first match.  (-l is specified by POSIX.)

       -m NUM, --max-count=NUM
              Stop reading a file after NUM matching lines.  If the  input  is  standard
              input from a regular file, and NUM matching lines are output, grep ensures
              that the standard input is positioned to just after the last matching line
              before  exiting,  regardless  of  the  presence of trailing context lines.
              This enables a calling process to resume a search.  When grep stops  after
              NUM matching lines, it outputs any trailing context lines.  When the -c or
              --count option is also used, grep does not output  a  count  greater  than
              NUM.   When the -v or --invert-match option is also used, grep stops after
              outputting NUM non-matching lines.

       -o, --only-matching
              Print only the matched (non-empty) parts of a  matching  line,  with  each
              such part on a separate output line.

       -q, --quiet, --silent
              Quiet;  do  not  write anything to standard output.  Exit immediately with
              zero status if any match is found, even if an error  was  detected.   Also
              see the -s or --no-messages option.  (-q is specified by POSIX.)

       -s, --no-messages
              Suppress   error   messages   about   nonexistent   or  unreadable  files.
              Portability note: unlike GNU grep, 7th Edition Unix grep did  not  conform
              to  POSIX,  because it lacked -q and its -s option behaved like GNU grep's
              -q option.  USG-style grep also lacked -q but its -s option  behaved  like
              GNU  grep.   Portable shell scripts should avoid both -q and -s and should
              redirect standard and error output to /dev/null instead.  (-s is specified
              by POSIX.)

   Output Line Prefix Control
       -b, --byte-offset
              Print  the  0-based  byte offset within the input file before each line of
              output.  If -o (--only-matching) is specified, print  the  offset  of  the
              matching part itself.

       -H, --with-filename
              Print  the  file  name  for each match.  This is the default when there is
              more than one file to search.

       -h, --no-filename
              Suppress the prefixing of file names on output.  This is the default  when
              there is only one file (or only standard input) to search.

       --label=LABEL
              Display  input  actually  coming  from standard input as input coming from
              file LABEL.  This is especially useful when implementing tools like zgrep,
              e.g.,  gzip  -cd  foo.gz | grep --label=foo -H something.  See also the -H
              option.

       -n, --line-number
              Prefix each line of output with the 1-based line number within  its  input
              file.  (-n is specified by POSIX.)

       -T, --initial-tab
              Make  sure  that  the first character of actual line content lies on a tab
              stop, so that the alignment of tabs looks normal.   This  is  useful  with
              options that prefix their output to the actual content: -H,-n, and -b.  In
              order to improve the probability that lines from a single  file  will  all
              start at the same column, this also causes the line number and byte offset
              (if present) to be printed in a minimum size field width.

       -u, --unix-byte-offsets
              Report Unix-style byte offsets.  This switch causes grep  to  report  byte
              offsets  as  if  the  file  were  a  Unix-style  text  file, i.e., with CR
              characters stripped off.  This will produce results identical  to  running
              grep  on  a  Unix  machine.  This option has no effect unless -b option is
              also used; it has no effect on platforms other than MS-DOS and MS-Windows.

       -Z, --null
              Output a zero byte (the ASCII NUL character) instead of the character that
              normally  follows  a file name.  For example, grep -lZ outputs a zero byte
              after each file name instead of the usual newline.  This option makes  the
              output  unambiguous, even in the presence of file names containing unusual
              characters like newlines.  This option can be used with commands like find
              -print0,  perl  -0, sort -z, and xargs -0 to process arbitrary file names,
              even those that contain newline characters.

   Context Line Control
       -A NUM, --after-context=NUM
              Print NUM lines of trailing context after matching lines.  Places  a  line
              containing  a  group separator (described under --group-separator) between
              contiguous groups of matches.  With the -o or --only-matching option, this
              has no effect and a warning is given.

       -B NUM, --before-context=NUM
              Print  NUM  lines of leading context before matching lines.  Places a line
              containing a group separator (described under  --group-separator)  between
              contiguous groups of matches.  With the -o or --only-matching option, this
              has no effect and a warning is given.

       -C NUM, -NUM, --context=NUM
              Print NUM lines of output context.   Places  a  line  containing  a  group
              separator (described under --group-separator) between contiguous groups of
              matches.  With the -o or --only-matching option, this has no effect and  a
              warning is given.

       --group-separator=SEP
              Use SEP as a group separator. By default SEP is double hyphen (--).

       --no-group-separator
              Use empty string as a group separator.

   File and Directory Selection
       -a, --text
              Process  a  binary  file  as  if  it  were text; this is equivalent to the
              --binary-files=text option.

       --binary-files=TYPE
              If the first few bytes of a file indicate that the  file  contains  binary
              data,  assume  that the file is of type TYPE.  By default, TYPE is binary,
              and grep normally outputs either a one-line message saying that  a  binary
              file  matches,  or  no  message if there is no match.  If TYPE is without-
              match, grep assumes that a binary file does not match; this is  equivalent
              to  the -I option.  If TYPE is text, grep processes a binary file as if it
              were  text;  this  is  equivalent  to  the  -a  option.    Warning:   grep
              --binary-files=text might output binary garbage, which can have nasty side
              effects if the output is a terminal and if the terminal driver  interprets
              some of it as commands.

       -D ACTION, --devices=ACTION
              If  an  input  file is a device, FIFO or socket, use ACTION to process it.
              By default, ACTION is read, which means that devices are read just  as  if
              they  were  ordinary  files.   If  ACTION  is  skip,  devices are silently
              skipped.

       -d ACTION, --directories=ACTION
              If an input file is a directory, use ACTION to process  it.   By  default,
              ACTION  is  read,  i.e.,  read  directories  just as if they were ordinary
              files.  If ACTION is  skip,  silently  skip  directories.   If  ACTION  is
              recurse,  read  all  files  under  each  directory, recursively, following
              symbolic links only if they are on the command line.  This  is  equivalent
              to the -r option.

       --exclude=GLOB
              Skip  files  whose  base  name  matches GLOB (using wildcard matching).  A
              file-name glob can use *, ?, and [...]  as wildcards, and  \  to  quote  a
              wildcard or backslash character literally.

       --exclude-from=FILE
              Skip  files  whose  base name matches any of the file-name globs read from
              FILE (using wildcard matching as described under --exclude).

       --exclude-dir=DIR
              Exclude directories matching the pattern DIR from recursive searches.

       -I     Process a binary file as if it did not  contain  matching  data;  this  is
              equivalent to the --binary-files=without-match option.

       --include=GLOB
              Search only files whose base name matches GLOB (using wildcard matching as
              described under --exclude).

       -r, --recursive
              Read all files under each directory, recursively, following symbolic links
              only  if  they  are  on  the  command  line.  This is equivalent to the -d
              recurse option.

       -R, --dereference-recursive
              Read all files under each directory,  recursively.   Follow  all  symbolic
              links, unlike -r.

   Other Options
       --line-buffered
              Use line buffering on output.  This can cause a performance penalty.

       -U, --binary
              Treat  the  file(s)  as  binary.  By default, under MS-DOS and MS-Windows,
              grep guesses the file type by looking at the contents of  the  first  32KB
              read  from  the  file.  If grep decides the file is a text file, it strips
              the CR characters  from  the  original  file  contents  (to  make  regular
              expressions  with  ^  and $ work correctly).  Specifying -U overrules this
              guesswork, causing all files  to  be  read  and  passed  to  the  matching
              mechanism verbatim; if the file is a text file with CR/LF pairs at the end
              of each line, this will cause some  regular  expressions  to  fail.   This
              option has no effect on platforms other than MS-DOS and MS-Windows.

       -z, --null-data
              Treat  the  input  as  a set of lines, each terminated by a zero byte (the
              ASCII NUL character) instead of a newline.  Like the -Z or --null  option,
              this  option  can  be used with commands like sort -z to process arbitrary
              file names.

REGULAR EXPRESSIONS
       A regular expression is a pattern that  describes  a  set  of  strings.   Regular
       expressions  are  constructed  analogously  to  arithmetic  expressions, by using
       various operators to combine smaller expressions.

       grep understands three different versions of regular expression syntax:  “basic,”
       “extended”  and  “perl.”  In  GNU grep,  there  is  no  difference  in  available
       functionality between basic and extended  syntaxes.   In  other  implementations,
       basic  regular  expressions are less powerful.  The following description applies
       to extended regular expressions; differences for basic  regular  expressions  are
       summarized  afterwards.   Perl regular expressions give additional functionality,
       and are documented in pcresyntax(3) and pcrepattern(3), but may not be  available
       on every system.

       The  fundamental  building blocks are the regular expressions that match a single
       character.  Most characters,  including  all  letters  and  digits,  are  regular
       expressions  that  match themselves.  Any meta-character with special meaning may
       be quoted by preceding it with a backslash.

       The period . matches any single character.

   Character Classes and Bracket Expressions
       A bracket expression is a list of characters enclosed by [ and ].  It matches any
       single  character in that list; if the first character of the list is the caret ^
       then it matches any  character  not  in  the  list.   For  example,  the  regular
       expression [0123456789] matches any single digit.

       Within  a  bracket  expression,  a  range  expression  consists of two characters
       separated by a hyphen.  It matches any single character that  sorts  between  the
       two  characters,  inclusive,  using the locale's collating sequence and character
       set.  For example, in the default C locale, [a-d] is equivalent to [abcd].   Many
       locales  sort  characters  in  dictionary  order,  and  in these locales [a-d] is
       typically not equivalent to [abcd]; it might  be  equivalent  to  [aBbCcDd],  for
       example.   To  obtain  the traditional interpretation of bracket expressions, you
       can use the C locale by setting the LC_ALL environment variable to the value C.

       Finally, certain named  classes  of  characters  are  predefined  within  bracket
       expressions,  as  follows.   Their  names  are  self  explanatory,  and  they are
       [:alnum:], [:alpha:],  [:cntrl:],  [:digit:],  [:graph:],  [:lower:],  [:print:],
       [:punct:],  [:space:], [:upper:], and [:xdigit:].  For example, [[:alnum:]] means
       the character class of numbers and letters in the current locale. In the C locale
       and  ASCII  character  set encoding, this is the same as [0-9A-Za-z].  (Note that
       the brackets in these class names are part of the symbolic  names,  and  must  be
       included  in  addition  to the brackets delimiting the bracket expression.)  Most
       meta-characters lose  their  special  meaning  inside  bracket  expressions.   To
       include  a literal ] place it first in the list.  Similarly, to include a literal
       ^ place it anywhere but first.  Finally, to include a literal - place it last.

   Anchoring
       The caret ^ and the dollar sign $ are meta-characters that respectively match the
       empty string at the beginning and end of a line.

   The Backslash Character and Special Expressions
       The  symbols  \<  and \> respectively match the empty string at the beginning and
       end of a word.  The symbol \b matches the empty string at the edge of a word, and
       \B  matches the empty string provided it's not at the edge of a word.  The symbol
       \w is a synonym for [_[:alnum:]] and \W is a synonym for [^_[:alnum:]].

   Repetition
       A regular expression may be followed by one of several repetition operators:
       ?      The preceding item is optional and matched at most once.
       *      The preceding item will be matched zero or more times.
       +      The preceding item will be matched one or more times.
       {n}    The preceding item is matched exactly n times.
       {n,}   The preceding item is matched n or more times.
       {,m}   The preceding item is matched at most m times.  This is a GNU extension.
       {n,m}  The preceding item is matched at least n times, but not more than m times.

   Concatenation
       Two regular expressions may be concatenated;  the  resulting  regular  expression
       matches any string formed by concatenating two substrings that respectively match
       the concatenated expressions.

   Alternation
       Two regular expressions may be joined by the  infix  operator  |;  the  resulting
       regular expression matches any string matching either alternate expression.

   Precedence
       Repetition  takes  precedence  over concatenation, which in turn takes precedence
       over alternation.  A whole expression may be enclosed in parentheses to  override
       these precedence rules and form a subexpression.

   Back References and Subexpressions
       The  back-reference  \n,  where  n  is  a  single  digit,  matches  the substring
       previously  matched  by  the  nth  parenthesized  subexpression  of  the  regular
       expression.

   Basic vs Extended Regular Expressions
       In  basic regular expressions the meta-characters ?, +, {, |, (, and ) lose their
       special meaning; instead use the backslashed versions \?, \+, \{, \|, \(, and \).

       Traditional  egrep  did  not  support  the  {  meta-character,  and  some   egrep
       implementations support \{ instead, so portable scripts should avoid { in grep -E
       patterns and should use [{] to match a literal {.

       GNU grep -E attempts to support traditional usage  by  assuming  that  {  is  not
       special  if  it  would  be  the  start of an invalid interval specification.  For
       example, the command  grep -E '{1'  searches  for  the  two-character  string  {1
       instead of reporting a syntax error in the regular expression.  POSIX allows this
       behavior as an extension, but portable scripts should avoid it.

ENVIRONMENT VARIABLES
       The behavior of grep is affected by the following environment variables.

       The locale for category LC_foo is specified by examining  the  three  environment
       variables LC_ALL, LC_foo, LANG, in that order.  The first of these variables that
       is set specifies the locale.  For example, if LC_ALL is not set, but  LC_MESSAGES
       is set to pt_BR, then the Brazilian Portuguese locale is used for the LC_MESSAGES
       category.  The C locale is used if none of these environment variables  are  set,
       if the locale catalog is not installed, or if grep was not compiled with national
       language support (NLS).

       GREP_OPTIONS
              This variable specifies default options to  be  placed  in  front  of  any
              explicit   options.    For   example,   if   GREP_OPTIONS   is  '--binary-
              files=without-match  --directories=skip',  grep  behaves  as  if  the  two
              options   --binary-files=without-match  and  --directories=skip  had  been
              specified  before  any  explicit  options.   Option   specifications   are
              separated  by  whitespace.   A backslash escapes the next character, so it
              can be used to specify an option containing whitespace or a backslash.

       GREP_COLOR
              This variable specifies the color used to  highlight  matched  (non-empty)
              text.  It is deprecated in favor of GREP_COLORS, but still supported.  The
              mt, ms, and mc capabilities of GREP_COLORS have priority over it.  It  can
              only  specify  the  color used to highlight the matching non-empty text in
              any matching line (a selected line when  the  -v  command-line  option  is
              omitted,  or  a context line when -v is specified).  The default is 01;31,
              which  means  a  bold  red  foreground  text  on  the  terminal's  default
              background.

       GREP_COLORS
              Specifies  the colors and other attributes used to highlight various parts
              of the output.  Its value is a colon-separated list of  capabilities  that
              defaults  to ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36 with the rv
              and ne boolean capabilities omitted (i.e., false).  Supported capabilities
              are as follows.

              sl=    SGR  substring  for whole selected lines (i.e., matching lines when
                     the -v command-line option is omitted, or non-matching  lines  when
                     -v  is specified).  If however the boolean rv capability and the -v
                     command-line option are  both  specified,  it  applies  to  context
                     matching lines instead.  The default is empty (i.e., the terminal's
                     default color pair).

              cx=    SGR substring for whole context  lines  (i.e.,  non-matching  lines
                     when  the -v command-line option is omitted, or matching lines when
                     -v is specified).  If however the boolean rv capability and the  -v
                     command-line option are both specified, it applies to selected non-
                     matching lines instead.  The default is empty (i.e., the terminal's
                     default color pair).

              rv     Boolean value that reverses (swaps) the meanings of the sl= and cx=
                     capabilities when the -v command-line  option  is  specified.   The
                     default is false (i.e., the capability is omitted).

              mt=01;31
                     SGR  substring  for  matching  non-empty  text in any matching line
                     (i.e., a selected line when the -v command-line option is  omitted,
                     or  a  context  line  when  -v  is  specified).   Setting  this  is
                     equivalent to setting both ms= and mc= at once to the  same  value.
                     The  default  is  a  bold red text foreground over the current line
                     background.

              ms=01;31
                     SGR substring for matching  non-empty  text  in  a  selected  line.
                     (This  is  only  used  when the -v command-line option is omitted.)
                     The effect of the sl= (or cx= if rv) capability remains active when
                     this  kicks in.  The default is a bold red text foreground over the
                     current line background.

              mc=01;31
                     SGR substring for matching non-empty text in a context line.  (This
                     is  only  used  when the -v command-line option is specified.)  The
                     effect of the cx= (or sl= if rv)  capability  remains  active  when
                     this  kicks in.  The default is a bold red text foreground over the
                     current line background.

              fn=35  SGR substring for file  names  prefixing  any  content  line.   The
                     default  is  a  magenta text foreground over the terminal's default
                     background.

              ln=32  SGR substring for line numbers prefixing  any  content  line.   The
                     default  is  a  green  text  foreground over the terminal's default
                     background.

              bn=32  SGR substring for byte offsets prefixing  any  content  line.   The
                     default  is  a  green  text  foreground over the terminal's default
                     background.

              se=36  SGR substring for separators that  are  inserted  between  selected
                     line  fields  (:),  between  context  line fields, (-), and between
                     groups of adjacent lines when nonzero context  is  specified  (--).
                     The  default  is a cyan text foreground over the terminal's default
                     background.

              ne     Boolean value that prevents clearing to the end of line using Erase
                     in  Line  (EL)  to  Right  (\33[K) each time a colorized item ends.
                     This is needed on terminals on which EL is not  supported.   It  is
                     otherwise  useful on terminals for which the back_color_erase (bce)
                     boolean  terminfo  capability  does  not  apply,  when  the  chosen
                     highlight  colors  do  not affect the background, or when EL is too
                     slow or causes too much flicker.  The default is false  (i.e.,  the
                     capability is omitted).

              Note  that  boolean  capabilities  have  no  =...  part.  They are omitted
              (i.e., false) by default and become true when specified.

              See the Select Graphic Rendition (SGR) section in the documentation of the
              text  terminal  that  is  used  for  permitted values and their meaning as
              character attributes.  These substring  values  are  integers  in  decimal
              representation  and  can be concatenated with semicolons.  grep takes care
              of assembling the result into a complete SGR sequence (\33[...m).   Common
              values  to concatenate include 1 for bold, 4 for underline, 5 for blink, 7
              for inverse, 39 for default foreground color,  30  to  37  for  foreground
              colors,  90  to 97 for 16-color mode foreground colors, 38;5;0 to 38;5;255
              for 88-color  and  256-color  modes  foreground  colors,  49  for  default
              background  color, 40 to 47 for background colors, 100 to 107 for 16-color
              mode background colors, and 48;5;0 to 48;5;255 for 88-color and  256-color
              modes background colors.

       LC_ALL, LC_COLLATE, LANG
              These  variables  specify  the  locale  for the LC_COLLATE category, which
              determines the collating sequence used to interpret range expressions like
              [a-z].

       LC_ALL, LC_CTYPE, LANG
              These  variables  specify  the  locale  for  the  LC_CTYPE category, which
              determines the type of characters, e.g., which characters are whitespace.

       LC_ALL, LC_MESSAGES, LANG
              These variables specify the locale for  the  LC_MESSAGES  category,  which
              determines the language that grep uses for messages.  The default C locale
              uses American English messages.

       POSIXLY_CORRECT
              If set, grep behaves as POSIX requires; otherwise, grep behaves more  like
              other  GNU  programs.   POSIX requires that options that follow file names
              must be treated as file names; by default, such options  are  permuted  to
              the  front  of  the  operand list and are treated as options.  Also, POSIX
              requires that unrecognized options be diagnosed as  “illegal”,  but  since
              they  are  not  really  against the law the default is to diagnose them as
              “invalid”.  POSIXLY_CORRECT  also  disables  _N_GNU_nonoption_argv_flags_,
              described below.

       _N_GNU_nonoption_argv_flags_
              (Here  N  is  grep's  numeric  process  ID.)  If the ith character of this
              environment variable's value is 1, do not consider the ith operand of grep
              to  be  an  option,  even  if  it appears to be one.  A shell can put this
              variable in the environment for each command  it  runs,  specifying  which
              operands  are  the  results  of file name wildcard expansion and therefore
              should not be treated as options.  This behavior is  available  only  with
              the GNU C library, and only when POSIXLY_CORRECT is not set.

EXIT STATUS
       Normally,  the exit status is 0 if selected lines are found and 1 otherwise.  But
       the exit status is 2 if an error occurred, unless the -q or --quiet  or  --silent
       option  is  used  and  a  selected line is found.  Note, however, that POSIX only
       mandates, for programs such as grep, cmp, and diff, that the exit status in  case
       of  error  be  greater  than  1;  it  is  therefore  advisable,  for  the sake of
       portability, to use logic that tests for this general condition instead of strict
       equality with 2.

COPYRIGHT
       Copyright 1998-2000, 2002, 2005-2014 Free Software Foundation, Inc.

       This  is  free  software;  see  the  source  for copying conditions.  There is NO
       warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

BUGS
   Reporting Bugs
       Email bug reports to  <bug-grep@gnu.org>,  a  mailing  list  whose  web  page  is
       <http://lists.gnu.org/mailman/listinfo/bug-grep>.  grep's Savannah bug tracker is
       located at <http://savannah.gnu.org/bugs/?group=grep>.

   Known Bugs
       Large repetition counts in the {n,m} construct may cause  grep  to  use  lots  of
       memory.    In   addition,  certain  other  obscure  regular  expressions  require
       exponential time and space, and may cause grep to run out of memory.

       Back-references are very slow, and may require exponential time.

SEE ALSO
   Regular Manual Pages
       awk(1), cmp(1), diff(1), find(1), gzip(1), perl(1),  sed(1),  sort(1),  xargs(1),
       zgrep(1),  read(2), pcre(3), pcresyntax(3), pcrepattern(3), terminfo(5), glob(7),
       regex(7).

   POSIX Programmer's Manual Page
       grep(1p).

   TeXinfo Documentation
       The full documentation for grep is maintained as a TeXinfo manual, which you  can
       read  at http://www.gnu.org/software/grep/manual/.  If the info and grep programs
       are properly installed at your site, the command

              info grep

       should give you access to the complete manual.

NOTES
       This man page is maintained only fitfully; the full documentation is  often  more
       up-to-date.

       GNU's not Unix, but Unix is a beast; its plural form is Unixen.



User Commands                         GNU grep 2.20                              GREP(1)
SED(1)                                User Commands                               SED(1)



NAME
       sed - stream editor for filtering and transforming text

SYNOPSIS
       sed [OPTION]... {script-only-if-no-other-script} [input-file]...

DESCRIPTION
       Sed  is a stream editor.  A stream editor is used to perform basic text transfor‐
       mations on an input stream (a file or input from a pipeline).  While in some ways
       similar to an editor which permits scripted edits (such as ed), sed works by mak‐
       ing only one pass over the input(s), and is consequently more efficient.  But  it
       is sed's ability to filter text in a pipeline which particularly distinguishes it
       from other types of editors.

       -n, --quiet, --silent

              suppress automatic printing of pattern space

       -e script, --expression=script

              add the script to the commands to be executed

       -f script-file, --file=script-file

              add the contents of script-file to the commands to be executed

       --follow-symlinks

              follow symlinks when processing in place

       -i[SUFFIX], --in-place[=SUFFIX]

              edit files in place (makes backup if SUFFIX supplied)

       -c, --copy

              use copy instead of rename when shuffling files in -i mode

       -b, --binary

              does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (  open  files
              in binary mode (CR+LFs are not treated specially))

       -l N, --line-length=N

              specify the desired line-wrap length for the `l' command

       --posix

              disable all GNU extensions.

       -r, --regexp-extended

              use extended regular expressions in the script.

       -s, --separate

              consider files as separate rather than as a single continuous long stream.

       -u, --unbuffered

              load  minimal  amounts  of  data from the input files and flush the output
              buffers more often

       -z, --null-data

              separate lines by NUL characters

       --help

              display this help and exit

       --version

              output version information and exit

       If no -e, --expression, -f, or --file option is given, then the first  non-option
       argument  is  taken  as the sed script to interpret.  All remaining arguments are
       names of input files; if no input files are specified, then the standard input is
       read.

       GNU  sed  home  page: <http://www.gnu.org/software/sed/>.  General help using GNU
       software:  <http://www.gnu.org/gethelp/>.    E-mail   bug   reports   to:   <bug-
       sed@gnu.org>.   Be sure to include the word ``sed'' somewhere in the ``Subject:''
       field.

COMMAND SYNOPSIS
       This is just a brief synopsis of sed commands to serve as a reminder to those who
       already know sed; other documentation (such as the texinfo document) must be con‐
       sulted for fuller descriptions.

   Zero-address ``commands''
       : label
              Label for b and t commands.

       #comment
              The comment extends until the next newline (or the  end  of  a  -e  script
              fragment).

       }      The closing bracket of a { } block.

   Zero- or One- address commands
       =      Print the current line number.

       a \

       text   Append text, which has each embedded newline preceded by a backslash.

       i \

       text   Insert text, which has each embedded newline preceded by a backslash.

       q [exit-code]
              Immediately  quit the sed script without processing any more input, except
              that if auto-print is not disabled  the  current  pattern  space  will  be
              printed.  The exit code argument is a GNU extension.

       Q [exit-code]
              Immediately  quit  the sed script without processing any more input.  This
              is a GNU extension.

       r filename
              Append text read from filename.

       R filename
              Append a line read from filename.  Each invocation of the command reads  a
              line from the file.  This is a GNU extension.

   Commands which accept address ranges
       {      Begin a block of commands (end with a }).

       b label
              Branch to label; if label is omitted, branch to end of script.

       c \

       text   Replace the selected lines with text, which has each embedded newline pre‐
              ceded by a backslash.

       d      Delete pattern space.  Start next cycle.

       D      If pattern space contains no newline, start a normal new cycle as if the d
              command was issued.  Otherwise, delete text in the pattern space up to the
              first newline, and restart cycle with the resultant pattern space, without
              reading a new line of input.

       h H    Copy/append pattern space to hold space.

       g G    Copy/append hold space to pattern space.

       l      List out the current line in a ``visually unambiguous'' form.

       l width
              List  out the current line in a ``visually unambiguous'' form, breaking it
              at width characters.  This is a GNU extension.

       n N    Read/append the next line of input into the pattern space.

       p      Print the current pattern space.

       P      Print up to the first embedded newline of the current pattern space.

       s/regexp/replacement/
              Attempt to match regexp against the pattern space.  If successful, replace
              that  portion  matched  with replacement.  The replacement may contain the
              special character & to refer to that portion of the  pattern  space  which
              matched, and the special escapes \1 through \9 to refer to the correspond‐
              ing matching sub-expressions in the regexp.

       t label
              If a s/// has done a successful substitution since the last input line was
              read  and since the last t or T command, then branch to label; if label is
              omitted, branch to end of script.

       T label
              If no s/// has done a successful substitution since the  last  input  line
              was read and since the last t or T command, then branch to label; if label
              is omitted, branch to end of script.  This is a GNU extension.

       w filename
              Write the current pattern space to filename.

       W filename
              Write the first line of the current pattern space to filename.  This is  a
              GNU extension.

       x      Exchange the contents of the hold and pattern spaces.

       y/source/dest/
              Transliterate  the  characters in the pattern space which appear in source
              to the corresponding character in dest.

Addresses
       Sed commands can be given with no addresses, in which case the  command  will  be
       executed  for  all  input lines; with one address, in which case the command will
       only be executed for input lines which match that address; or with two addresses,
       in  which  case  the command will be executed for all input lines which match the
       inclusive range of lines starting from the first address and  continuing  to  the
       second  address.   Three  things  to  note  about  address  ranges: the syntax is
       addr1,addr2 (i.e., the addresses are separated by a comma); the line which  addr1
       matched  will  always  be accepted, even if addr2 selects an earlier line; and if
       addr2 is a regexp, it will not be tested against the line that addr1 matched.

       After the address (or address-range),  and  before  the  command,  a  !   may  be
       inserted,  which specifies that the command shall only be executed if the address
       (or address-range) does not match.

       The following address types are supported:

       number Match only the specified line number (which increments cumulatively across
              files, unless the -s option is specified on the command line).

       first~step
              Match  every step'th line starting with line first.  For example, ``sed -n
              1~2p'' will print all the odd-numbered lines in the input stream, and  the
              address  2~5 will match every fifth line, starting with the second.  first
              can be zero; in this case, sed operates as  if  it  were  equal  to  step.
              (This is an extension.)

       $      Match the last line.

       /regexp/
              Match lines matching the regular expression regexp.

       \cregexpc
              Match  lines  matching  the  regular  expression regexp.  The c may be any
              character.

       GNU sed also supports some special 2-address forms:

       0,addr2
              Start out in "matched first address" state, until addr2 is found.  This is
              similar  to  1,addr2,  except that if addr2 matches the very first line of
              input the 0,addr2 form will be at  the  end  of  its  range,  whereas  the
              1,addr2 form will still be at the beginning of its range.  This works only
              when addr2 is a regular expression.

       addr1,+N
              Will match addr1 and the N lines following addr1.

       addr1,~N
              Will match addr1 and the lines following addr1 until the next  line  whose
              input line number is a multiple of N.

REGULAR EXPRESSIONS
       POSIX.2  BREs  should be supported, but they aren't completely because of perfor‐
       mance problems.  The \n sequence in a  regular  expression  matches  the  newline
       character, and similarly for \a, \t, and other sequences.

BUGS
       E-mail  bug reports to bug-sed@gnu.org.  Also, please include the output of ``sed
       --version'' in the body of your report if at all possible.

AUTHOR
       Written by Jay Fenlason, Tom Lord, Ken Pizzini, and Paolo Bonzini.  GNU sed  home
       page:  <http://www.gnu.org/software/sed/>.   General  help  using  GNU  software:
       <http://www.gnu.org/gethelp/>.  E-mail bug  reports  to:  <bug-sed@gnu.org>.   Be
       sure to include the word ``sed'' somewhere in the ``Subject:'' field.

COPYRIGHT
       Copyright  © 2012 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version
       3 or later <http://gnu.org/licenses/gpl.html>.
       This is free software: you are free to change and redistribute it.  There  is  NO
       WARRANTY, to the extent permitted by law.

SEE ALSO
       awk(1), ed(1), grep(1), tr(1), perlre(1), sed.info, any of various books on sed,
       the sed FAQ (http://sed.sf.net/grabbag/tutorials/sedfaq.txt),
       http://sed.sf.net/grabbag/.

       The full documentation for sed is maintained as a Texinfo manual.  If the info
       and sed programs are properly installed at your site, the command

              info sed

       should give you access to the complete manual.



sed 4.2.2                            September 2020                               SED(1)
GAWK(1)                             Utility Commands                             GAWK(1)



NAME
       gawk - pattern scanning and processing language

SYNOPSIS
       gawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...
       gawk [ POSIX or GNU style options ] [ -- ] program-text file ...

       pgawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...
       pgawk [ POSIX or GNU style options ] [ -- ] program-text file ...

       dgawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...

DESCRIPTION
       Gawk  is  the  GNU  Project's implementation of the AWK programming language.  It
       conforms to the definition of the language in the POSIX  1003.1  Standard.   This
       version  in  turn is based on the description in The AWK Programming Language, by
       Aho, Kernighan, and Weinberger.  Gawk provides the additional features  found  in
       the current version of UNIX awk and a number of GNU-specific extensions.

       The command line consists of options to gawk itself, the AWK program text (if not
       supplied via the -f or --file options), and values to be made  available  in  the
       ARGC and ARGV pre-defined AWK variables.

       Pgawk  is  the  profiling version of gawk.  It is identical in every way to gawk,
       except that programs run more slowly, and it automatically produces an  execution
       profile in the file awkprof.out when done.  See the --profile option, below.

       Dgawk  is  an awk debugger. Instead of running the program directly, it loads the
       AWK source code and then prompts for debugging commands.  Unlike gawk and  pgawk,
       dgawk  only processes AWK program source provided with the -f option.  The debug‐
       ger is documented in GAWK: Effective AWK Programming.

OPTION FORMAT
       Gawk options may be either traditional POSIX-style one letter  options,  or  GNU-
       style  long  options.   POSIX options start with a single “-”, while long options
       start with “--”.  Long options are provided for both  GNU-specific  features  and
       for POSIX-mandated features.

       Gawk- specific options are typically used in long-option form.  Arguments to long
       options are either joined with the option by an = sign, with no intervening  spa‐
       ces, or they may be provided in the next command line argument.  Long options may
       be abbreviated, as long as the abbreviation remains unique.

       Additionally, each long option has a corresponding  short  option,  so  that  the
       option's functionality may be used from within #!  executable scripts.

OPTIONS
       Gawk  accepts the following options.  Standard options are listed first, followed
       by options for gawk extensions, listed alphabetically by short option.

       -f program-file
       --file program-file
              Read the AWK program source from the file program-file,  instead  of  from
              the  first  command line argument.  Multiple -f (or --file) options may be
              used.

       -F fs
       --field-separator fs
              Use fs for the input field separator (the value of the FS predefined vari‐
              able).

       -v var=val
       --assign var=val
              Assign  the value val to the variable var, before execution of the program
              begins.  Such variable values are available to the BEGIN block of  an  AWK
              program.

       -b
       --characters-as-bytes
              Treat  all input data as single-byte characters. In other words, don't pay
              any attention to the locale information when attempting to process strings
              as multibyte characters.  The --posix option overrides this one.

       -c
       --traditional
              Run  in  compatibility  mode.  In compatibility mode, gawk behaves identi‐
              cally to UNIX awk; none of the  GNU-specific  extensions  are  recognized.
              See GNU EXTENSIONS, below, for more information.

       -C
       --copyright
              Print  the  short  version of the GNU copyright information message on the
              standard output and exit successfully.

       -d[file]
       --dump-variables[=file]
              Print a sorted list of global variables, their types and final  values  to
              file.   If  no file is provided, gawk uses a file named awkvars.out in the
              current directory.
              Having a list of all the global variables is a good way to look for  typo‐
              graphical  errors in your programs.  You would also use this option if you
              have a large program with a lot of functions, and you want to be sure that
              your  functions don't inadvertently use global variables that you meant to
              be local.  (This is a particularly easy mistake to make with simple  vari‐
              able names like i, j, and so on.)

       -e program-text
       --source program-text
              Use  program-text as AWK program source code.  This option allows the easy
              intermixing of library functions (used via the -f and --file options) with
              source  code  entered  on  the command line.  It is intended primarily for
              medium to large AWK programs used in shell scripts.

       -E file
       --exec file
              Similar to -f, however, this is option is the last  one  processed.   This
              should  be  used  with  #!  scripts, particularly for CGI applications, to
              avoid passing in options or source code (!) on the  command  line  from  a
              URL.  This option disables command-line variable assignments.

       -g
       --gen-pot
              Scan  and  parse the AWK program, and generate a GNU .pot (Portable Object
              Template) format file on standard output with entries for all  localizable
              strings  in the program.  The program itself is not executed.  See the GNU
              gettext distribution for more information on .pot files.

       -h
       --help Print a relatively short summary of the available options on the  standard
              output.   (Per the GNU Coding Standards, these options cause an immediate,
              successful exit.)

       -L [value]
       --lint[=value]
              Provide warnings about constructs that  are  dubious  or  non-portable  to
              other AWK implementations.  With an optional argument of fatal, lint warn‐
              ings become fatal errors.  This may be drastic, but its use will certainly
              encourage the development of cleaner AWK programs.  With an optional argu‐
              ment of invalid, only warnings about things that are actually invalid  are
              issued. (This is not fully implemented yet.)

       -n
       --non-decimal-data
              Recognize  octal  and  hexadecimal  values in input data.  Use this option
              with great caution!

       -N
       --use-lc-numeric
              This forces gawk to use the locale's decimal point character when  parsing
              input  data.  Although the POSIX standard requires this behavior, and gawk
              does so when --posix is in effect, the default is  to  follow  traditional
              behavior  and use a period as the decimal point, even in locales where the
              period is not the decimal point  character.   This  option  overrides  the
              default  behavior,  without  the  full draconian strictness of the --posix
              option.

       -O
       --optimize
              Enable optimizations upon the  internal  representation  of  the  program.
              Currently, this includes just simple constant-folding. The gawk maintainer
              hopes to add additional optimizations over time.

       -p[prof_file]
       --profile[=prof_file]
              Send profiling data to prof_file.  The default is awkprof.out.   When  run
              with  gawk, the profile is just a “pretty printed” version of the program.
              When run with pgawk, the profile contains execution counts of each  state‐
              ment  in  the program in the left margin and function call counts for each
              user-defined function.

       -P
       --posix
              This turns on compatibility mode, with the following  additional  restric‐
              tions:

              · \x escape sequences are not recognized.

              · Only  space  and  tab act as field separators when FS is set to a single
                space, newline does not.

              · You cannot continue lines after ?  and :.

              · The synonym func for the keyword function is not recognized.

              · The operators ** and **= cannot be used in place of ^ and ^=.

       -r
       --re-interval
              Enable the use of interval expressions in regular expression matching (see
              Regular  Expressions, below).  Interval expressions were not traditionally
              available in the AWK language.  The POSIX standard added them, to make awk
              and  egrep  consistent  with each other.  They are enabled by default, but
              this option remains for use with --traditional.

       -R
       --command file
              Dgawk only.  Read stored debugger commands from file.

       -S
       --sandbox
              Runs gawk in sandbox mode, disabling the system()  function,  input  redi‐
              rection  with getline, output redirection with print and printf, and load‐
              ing dynamic extensions.  Command execution  (through  pipelines)  is  also
              disabled.  This effectively blocks a script from accessing local resources
              (except for the files specified on the command line).

       -t
       --lint-old
              Provide warnings about constructs that are not portable  to  the  original
              version of Unix awk.

       -V
       --version
              Print version information for this particular copy of gawk on the standard
              output.  This is useful mainly for knowing if the current copy of gawk  on
              your system is up to date with respect to whatever the Free Software Foun‐
              dation is distributing.  This is also useful when  reporting  bugs.   (Per
              the  GNU  Coding  Standards,  these options cause an immediate, successful
              exit.)

       --     Signal the end of options. This is useful to allow  further  arguments  to
              the  AWK  program  itself  to start with a “-”.  This provides consistency
              with the argument parsing convention used by most other POSIX programs.

       In compatibility mode, any other options are flagged as invalid, but  are  other‐
       wise  ignored.   In  normal operation, as long as program text has been supplied,
       unknown options are passed on to the AWK program in the ARGV array  for  process‐
       ing.   This  is  particularly  useful  for running AWK programs via the “#!” exe‐
       cutable interpreter mechanism.

AWK PROGRAM EXECUTION
       An AWK program consists of a sequence of pattern-action statements  and  optional
       function definitions.

              @include "filename" pattern   { action statements }
              function name(parameter list) { statements }

       Gawk  first  reads the program source from the program-file(s) if specified, from
       arguments to --source, or from the first non-option argument on the command line.
       The -f and --source options may be used multiple times on the command line.  Gawk
       reads the program text as if all the program-files and command line source  texts
       had  been  concatenated  together.   This is useful for building libraries of AWK
       functions, without having to include them in each new AWK program that uses them.
       It also provides the ability to mix library functions with command line programs.

       In  addition,  lines  beginning with @include may be used to include other source
       files into your program, making library use even easier.

       The environment variable AWKPATH specifies a search  path  to  use  when  finding
       source  files  named  with  the  -f option.  If this variable does not exist, the
       default path  is  ".:/usr/local/share/awk".   (The  actual  directory  may  vary,
       depending upon how gawk was built and installed.)  If a file name given to the -f
       option contains a “/” character, no path search is performed.

       Gawk executes AWK programs in the following order.  First, all  variable  assign‐
       ments specified via the -v option are performed.  Next, gawk compiles the program
       into an internal form.  Then, gawk executes the code in the  BEGIN  block(s)  (if
       any),  and  then  proceeds  to  read  each  file  named  in the ARGV array (up to
       ARGV[ARGC]).  If there are no files named on the command  line,  gawk  reads  the
       standard input.

       If  a  filename on the command line has the form var=val it is treated as a vari‐
       able assignment.  The variable var will be assigned the value val.  (This happens
       after  any  BEGIN  block(s)  have been run.)  Command line variable assignment is
       most useful for dynamically assigning values to the variables AWK uses to control
       how  input  is broken into fields and records.  It is also useful for controlling
       state if multiple passes are needed over a single data file.

       If the value of a particular element of ARGV is empty (""), gawk skips over it.

       For each input file, if a BEGINFILE rule exists,  gawk  executes  the  associated
       code  before  processing  the  contents of the file. Similarly, gawk executes the
       code associated with ENDFILE after processing the file.

       For each record in the input, gawk tests to see if it matches any pattern in  the
       AWK  program.  For each pattern that the record matches, the associated action is
       executed.  The patterns are tested in the order they occur in the program.

       Finally, after all the input is exhausted, gawk executes  the  code  in  the  END
       block(s) (if any).

   Command Line Directories
       According  to POSIX, files named on the awk command line must be text files.  The
       behavior is ``undefined'' if they are not.  Most versions of awk treat  a  direc‐
       tory on the command line as a fatal error.

       Starting  with  version  4.0  of gawk, a directory on the command line produces a
       warning, but is otherwise skipped.  If either of  the  --posix  or  --traditional
       options  is  given, then gawk reverts to treating directories on the command line
       as a fatal error.

VARIABLES, RECORDS AND FIELDS
       AWK variables are dynamic; they come into existence when  they  are  first  used.
       Their  values  are  either  floating-point numbers or strings, or both, depending
       upon how they are used.  AWK also has one dimensional arrays; arrays with  multi‐
       ple dimensions may be simulated.  Several pre-defined variables are set as a pro‐
       gram runs; these are described as needed and summarized below.

   Records
       Normally, records are separated by  newline  characters.   You  can  control  how
       records  are separated by assigning values to the built-in variable RS.  If RS is
       any single character, that character separates records.  Otherwise, RS is a regu‐
       lar expression.  Text in the input that matches this regular expression separates
       the record.  However, in compatibility mode, only  the  first  character  of  its
       string  value  is  used for separating records.  If RS is set to the null string,
       then records are separated by blank lines.  When RS is set to  the  null  string,
       the  newline  character always acts as a field separator, in addition to whatever
       value FS may have.

   Fields
       As each input record is read, gawk splits the record into fields, using the value
       of  the  FS variable as the field separator.  If FS is a single character, fields
       are separated by that character.  If FS is the null string, then each  individual
       character becomes a separate field.  Otherwise, FS is expected to be a full regu‐
       lar expression.  In the special case that FS is a single space, fields are  sepa‐
       rated  by runs of spaces and/or tabs and/or newlines.  (But see the section POSIX
       COMPATIBILITY, below).  NOTE: The value of IGNORECASE (see  below)  also  affects
       how  fields  are split when FS is a regular expression, and how records are sepa‐
       rated when RS is a regular expression.

       If the FIELDWIDTHS variable is set to a space separated  list  of  numbers,  each
       field  is  expected  to have fixed width, and gawk splits up the record using the
       specified widths.  The value of FS is ignored.  Assigning a new value  to  FS  or
       FPAT overrides the use of FIELDWIDTHS.

       Similarly, if the FPAT variable is set to a string representing a regular expres‐
       sion, each field is made up of text that matches that regular expression. In this
       case, the regular expression describes the fields themselves, instead of the text
       that separates the fields.  Assigning a new value to FS or FIELDWIDTHS  overrides
       the use of FPAT.

       Each  field in the input record may be referenced by its position, $1, $2, and so
       on.  $0 is the whole record.  Fields need not be referenced by constants:

              n = 5
              print $n

       prints the fifth field in the input record.

       The variable NF is set to the total number of fields in the input record.

       References to non-existent fields (i.e.  fields  after  $NF)  produce  the  null-
       string.  However, assigning to a non-existent field (e.g., $(NF+2) = 5) increases
       the value of NF, creates any intervening fields with the  null  string  as  their
       value,  and  causes the value of $0 to be recomputed, with the fields being sepa‐
       rated by the value of OFS.  References to negative numbered fields cause a  fatal
       error.   Decrementing  NF  causes  the  values of fields past the new value to be
       lost, and the value of $0 to be recomputed, with the fields  being  separated  by
       the value of OFS.

       Assigning a value to an existing field causes the whole record to be rebuilt when
       $0 is referenced.  Similarly, assigning a value to $0 causes  the  record  to  be
       resplit, creating new values for the fields.

   Built-in Variables
       Gawk's built-in variables are:

       ARGC        The  number  of  command  line arguments (does not include options to
                   gawk, or the program source).

       ARGIND      The index in ARGV of the current file being processed.

       ARGV        Array of command line arguments.  The array is indexed from 0 to ARGC
                   - 1.  Dynamically changing the contents of ARGV can control the files
                   used for data.

       BINMODE     On non-POSIX systems, specifies use of “binary”  mode  for  all  file
                   I/O.   Numeric values of 1, 2, or 3, specify that input files, output
                   files, or all files, respectively, should  use  binary  I/O.   String
                   values  of  "r",  or  "w"  specify that input files, or output files,
                   respectively, should use binary I/O.  String values of "rw"  or  "wr"
                   specify that all files should use binary I/O.  Any other string value
                   is treated as "rw", but generates a warning message.

       CONVFMT     The conversion format for numbers, "%.6g", by default.

       ENVIRON     An array containing the values of the current environment.  The array
                   is indexed by the environment variables, each element being the value
                   of that  variable  (e.g.,  ENVIRON["HOME"]  might  be  /home/arnold).
                   Changing  this array does not affect the environment seen by programs
                   which gawk spawns via redirection or the system() function.

       ERRNO       If a system error occurs either doing a redirection for getline, dur‐
                   ing  a read for getline, or during a close(), then ERRNO will contain
                   a string describing the error.  The value is subject  to  translation
                   in non-English locales.

       FIELDWIDTHS A  whitespace  separated list of field widths.  When set, gawk parses
                   the input into fields of fixed width, instead of using the  value  of
                   the FS variable as the field separator.  See Fields, above.

       FILENAME    The name of the current input file.  If no files are specified on the
                   command line, the value of FILENAME is  “-”.   However,  FILENAME  is
                   undefined inside the BEGIN block (unless set by getline).

       FNR         The input record number in the current input file.

       FPAT        A  regular  expression  describing  the  contents  of the fields in a
                   record.  When set, gawk parses  the  input  into  fields,  where  the
                   fields  match  the  regular expression, instead of using the value of
                   the FS variable as the field separator.  See Fields, above.

       FS          The input field separator, a space by default.  See Fields, above.

       IGNORECASE  Controls the case-sensitivity of all regular  expression  and  string
                   operations.   If IGNORECASE has a non-zero value, then string compar‐
                   isons and pattern matching in rules,  field  splitting  with  FS  and
                   FPAT,  record  separating with RS, regular expression matching with ~
                   and !~, and  the  gensub(),  gsub(),  index(),  match(),  patsplit(),
                   split(), and sub() built-in functions all ignore case when doing reg‐
                   ular  expression  operations.   NOTE:  Array  subscripting   is   not
                   affected.  However, the asort() and asorti() functions are affected.
                   Thus,  if  IGNORECASE  is  not equal to zero, /aB/ matches all of the
                   strings "ab", "aB", "Ab", and "AB".  As with all AWK  variables,  the
                   initial  value  of  IGNORECASE is zero, so all regular expression and
                   string operations are normally case-sensitive.

       LINT        Provides dynamic control of the --lint option from within an AWK pro‐
                   gram.  When true, gawk prints lint warnings. When false, it does not.
                   When assigned the string value "fatal", lint  warnings  become  fatal
                   errors,  exactly like --lint=fatal.  Any other true value just prints
                   warnings.

       NF          The number of fields in the current input record.

       NR          The total number of input records seen so far.

       OFMT        The output format for numbers, "%.6g", by default.

       OFS         The output field separator, a space by default.

       ORS         The output record separator, by default a newline.

       PROCINFO    The elements of this array provide access to  information  about  the
                   running  AWK  program.  On some systems, there may be elements in the
                   array, "group1" through "groupn" for some n, which is the  number  of
                   supplementary  groups  that  the process has.  Use the in operator to
                   test for these elements.  The following elements are guaranteed to be
                   available:

                   PROCINFO["egid"]    the value of the getegid(2) system call.

                   PROCINFO["strftime"]
                                       The default time format string for strftime().

                   PROCINFO["euid"]    the value of the geteuid(2) system call.

                   PROCINFO["FS"]      "FS"  if  field  splitting  with FS is in effect,
                                       "FPAT" if field splitting with FPAT is in effect,
                                       or  "FIELDWIDTHS"  if field splitting with FIELD‐
                                       WIDTHS is in effect.

                   PROCINFO["gid"]     the value of the getgid(2) system call.

                   PROCINFO["pgrpid"]  the process group ID of the current process.

                   PROCINFO["pid"]     the process ID of the current process.

                   PROCINFO["ppid"]    the parent process ID of the current process.

                   PROCINFO["uid"]     the value of the getuid(2) system call.

                   PROCINFO["sorted_in"]
                                       If this element  exists  in  PROCINFO,  then  its
                                       value  controls the order in which array elements
                                       are traversed in for loops.  Supported values are
                                       "@ind_str_asc",  "@ind_num_asc", "@val_type_asc",
                                       "@val_str_asc", "@val_num_asc",  "@ind_str_desc",
                                       "@ind_num_desc",                "@val_type_desc",
                                       "@val_str_desc",       "@val_num_desc",       and
                                       "@unsorted".   The  value can also be the name of
                                       any comparison function defined as follows:

                          function cmp_func(i1, v1, i2, v2)

                   where i1 and i2 are the indices, and v1 and v2 are the  corresponding
                   values of the two elements being compared.  It should return a number
                   less than, equal to, or greater than 0, depending on how the elements
                   of the array are to be ordered.

                   PROCINFO["version"]
                          the version of gawk.

       RS          The input record separator, by default a newline.

       RT          The  record  terminator.  Gawk sets RT to the input text that matched
                   the character or regular expression specified by RS.

       RSTART      The index of the first character matched by match(); 0 if  no  match.
                   (This implies that character indices start at one.)

       RLENGTH     The length of the string matched by match(); -1 if no match.

       SUBSEP      The character used to separate multiple subscripts in array elements,
                   by default "\034".

       TEXTDOMAIN  The text domain of the AWK program; used to find the localized trans‐
                   lations for the program's strings.

   Arrays
       Arrays  are subscripted with an expression between square brackets ([ and ]).  If
       the expression is an expression list (expr, expr ...)  then the  array  subscript
       is a string consisting of the concatenation of the (string) value of each expres‐
       sion, separated by the value of the SUBSEP variable.  This facility  is  used  to
       simulate multiply dimensioned arrays.  For example:

              i = "A"; j = "B"; k = "C"
              x[i, j, k] = "hello, world\n"

       assigns  the  string  "hello,  world\n"  to  the  element of the array x which is
       indexed by the string "A\034B\034C".  All arrays in  AWK  are  associative,  i.e.
       indexed by string values.

       The  special  operator in may be used to test if an array has an index consisting
       of a particular value:

              if (val in array)
                   print array[val]

       If the array has multiple subscripts, use (i, j) in array.

       The in construct may also be used in a for loop to iterate over all the  elements
       of an array.

       An  element  may be deleted from an array using the delete statement.  The delete
       statement may also be used to delete the entire contents of  an  array,  just  by
       specifying the array name without a subscript.

       gawk  supports true multidimensional arrays. It does not require that such arrays
       be ``rectangular'' as in C or C++.  For example:
              a[1] = 5
              a[2][1] = 6
              a[2][2] = 7

   Variable Typing And Conversion
       Variables and fields may be (floating point) numbers, or strings, or  both.   How
       the  value  of  a variable is interpreted depends upon its context.  If used in a
       numeric expression, it will be treated as a number; if used as a string  it  will
       be treated as a string.

       To  force  a  variable  to be treated as a number, add 0 to it; to force it to be
       treated as a string, concatenate it with the null string.

       When a string must be converted to a number, the conversion is accomplished using
       strtod(3).   A number is converted to a string by using the value of CONVFMT as a
       format string for sprintf(3), with the numeric value of the variable as the argu‐
       ment.   However, even though all numbers in AWK are floating-point, integral val‐
       ues are always converted as integers.  Thus, given

              CONVFMT = "%2.2f"
              a = 12
              b = a ""

       the variable b has a string value of "12" and not "12.00".

       NOTE: When operating in POSIX  mode  (such  as  with  the  --posix  command  line
       option),  beware  that locale settings may interfere with the way decimal numbers
       are treated: the decimal separator of the numbers you are feeding  to  gawk  must
       conform to what your locale would expect, be it a comma (,) or a period (.).

       Gawk performs comparisons as follows: If two variables are numeric, they are com‐
       pared numerically.  If one value is numeric and the other has a string value that
       is  a  “numeric  string,” then comparisons are also done numerically.  Otherwise,
       the numeric value is converted to a string and a string comparison is  performed.
       Two strings are compared, of course, as strings.

       Note  that  string  constants,  such  as  "57", are not numeric strings, they are
       string constants.  The idea of “numeric string” only applies to  fields,  getline
       input,  FILENAME,  ARGV  elements,  ENVIRON elements and the elements of an array
       created by split() or patsplit() that are numeric strings.   The  basic  idea  is
       that  user input, and only user input, that looks numeric, should be treated that
       way.

       Uninitialized variables have the numeric value 0 and the  string  value  ""  (the
       null, or empty, string).

   Octal and Hexadecimal Constants
       You  may  use  C-style octal and hexadecimal constants in your AWK program source
       code.  For example, the octal value 011 is equal to decimal 9, and the  hexadeci‐
       mal value 0x11 is equal to decimal 17.

   String Constants
       String  constants  in  AWK  are  sequences  of characters enclosed between double
       quotes (like "value").  Within strings, certain escape sequences are  recognized,
       as in C.  These are:

       \\   A literal backslash.

       \a   The “alert” character; usually the ASCII BEL character.

       \b   backspace.

       \f   form-feed.

       \n   newline.

       \r   carriage return.

       \t   horizontal tab.

       \v   vertical tab.

       \xhex digits
            The  character represented by the string of hexadecimal digits following the
            \x.  As in ANSI C, all following hexadecimal digits are considered  part  of
            the  escape sequence.  (This feature should tell us something about language
            design by committee.)  E.g., "\x1B" is the ASCII ESC (escape) character.

       \ddd The character represented by the 1-, 2-, or 3-digit sequence of  octal  dig‐
            its.  E.g., "\033" is the ASCII ESC (escape) character.

       \c   The literal character c.

       The  escape sequences may also be used inside constant regular expressions (e.g.,
       /[ \t\f\n\r\v]/ matches whitespace characters).

       In compatibility mode, the characters represented by octal and hexadecimal escape
       sequences are treated literally when used in regular expression constants.  Thus,
       /a\52b/ is equivalent to /a\*b/.

PATTERNS AND ACTIONS
       AWK is a line-oriented language.  The pattern comes first, and then  the  action.
       Action statements are enclosed in { and }.  Either the pattern may be missing, or
       the action may be missing, but, of course, not both.  If the pattern is  missing,
       the  action  is  executed  for every single record of input.  A missing action is
       equivalent to

              { print }

       which prints the entire record.

       Comments begin with the # character, and continue until  the  end  of  the  line.
       Blank  lines may be used to separate statements.  Normally, a statement ends with
       a newline, however, this is not the case for lines ending in a comma,  {,  ?,  :,
       &&,  or  ||.  Lines ending in do or else also have their statements automatically
       continued on the following line.  In other cases, a line can be continued by end‐
       ing it with a “\”, in which case the newline is ignored.

       Multiple  statements  may be put on one line by separating them with a “;”.  This
       applies to both the statements within the action part of  a  pattern-action  pair
       (the usual case), and to the pattern-action statements themselves.

   Patterns
       AWK patterns may be one of the following:

              BEGIN
              END
              BEGINFILE
              ENDFILE
              /regular expression/
              relational expression
              pattern && pattern
              pattern || pattern
              pattern ? pattern : pattern
              (pattern)
              ! pattern
              pattern1, pattern2

       BEGIN  and END are two special kinds of patterns which are not tested against the
       input.  The action parts of all BEGIN patterns are merged as if  all  the  state‐
       ments  had been written in a single BEGIN block.  They are executed before any of
       the input is read.  Similarly, all the END blocks are merged, and  executed  when
       all  the  input  is exhausted (or when an exit statement is executed).  BEGIN and
       END patterns cannot be combined  with  other  patterns  in  pattern  expressions.
       BEGIN and END patterns cannot have missing action parts.

       BEGINFILE  and  ENDFILE are additional special patterns whose bodies are executed
       before reading the first record of each command line input file and after reading
       the last record of each file.  Inside the BEGINFILE rule, the value of ERRNO will
       be the empty string if the file could be opened successfully.   Otherwise,  there
       is  some  problem  with  the file and the code should use nextfile to skip it. If
       that is not done, gawk produces its usual fatal error for files  that  cannot  be
       opened.

       For  /regular expression/ patterns, the associated statement is executed for each
       input record that matches the regular expression.  Regular  expressions  are  the
       same as those in egrep(1), and are summarized below.

       A relational expression may use any of the operators defined below in the section
       on actions.  These generally test whether certain fields  match  certain  regular
       expressions.

       The  &&,  ||,  and  !   operators  are  logical AND, logical OR, and logical NOT,
       respectively, as in C.  They do short-circuit evaluation, also as in C,  and  are
       used  for  combining  more  primitive pattern expressions.  As in most languages,
       parentheses may be used to change the order of evaluation.

       The ?: operator is like the same operator in C.  If the  first  pattern  is  true
       then  the  pattern  used  for  testing is the second pattern, otherwise it is the
       third.  Only one of the second and third patterns is evaluated.

       The pattern1, pattern2 form of an expression  is  called  a  range  pattern.   It
       matches  all input records starting with a record that matches pattern1, and con‐
       tinuing until a record that matches pattern2, inclusive.   It  does  not  combine
       with any other sort of pattern expression.

   Regular Expressions
       Regular  expressions  are the extended kind found in egrep.  They are composed of
       characters as follows:

       c          matches the non-metacharacter c.

       \c         matches the literal character c.

       .          matches any character including newline.

       ^          matches the beginning of a string.

       $          matches the end of a string.

       [abc...]   character list, matches any of the characters abc....

       [^abc...]  negated character list, matches any character except abc....

       r1|r2      alternation: matches either r1 or r2.

       r1r2       concatenation: matches r1, and then r2.

       r+         matches one or more r's.

       r*         matches zero or more r's.

       r?         matches zero or one r's.

       (r)        grouping: matches r.

       r{n}
       r{n,}
       r{n,m}     One or two numbers inside braces denote an  interval  expression.   If
                  there  is one number in the braces, the preceding regular expression r
                  is repeated n times.  If there are two numbers separated by a comma, r
                  is repeated n to m times.  If there is one number followed by a comma,
                  then r is repeated at least n times.

       \y         matches the empty string at either the beginning or the end of a word.

       \B         matches the empty string within a word.

       \<         matches the empty string at the beginning of a word.

       \>         matches the empty string at the end of a word.

       \s         matches any whitespace character.

       \S         matches any nonwhitespace character.

       \w         matches any word-constituent character (letter, digit, or underscore).

       \W         matches any character that is not word-constituent.

       \`         matches the empty string at the beginning of a buffer (string).

       \'         matches the empty string at the end of a buffer.

       The escape sequences that are valid in string  constants  (see  below)  are  also
       valid in regular expressions.

       Character  classes  are  a feature introduced in the POSIX standard.  A character
       class is a special notation for describing lists of characters that have  a  spe‐
       cific attribute, but where the actual characters themselves can vary from country
       to country and/or from character set to character set.  For example,  the  notion
       of what is an alphabetic character differs in the USA and in France.

       A  character class is only valid in a regular expression inside the brackets of a
       character list.  Character classes consist of [:, a keyword denoting  the  class,
       and :].  The character classes defined by the POSIX standard are:

       [:alnum:]  Alphanumeric characters.

       [:alpha:]  Alphabetic characters.

       [:blank:]  Space or tab characters.

       [:cntrl:]  Control characters.

       [:digit:]  Numeric characters.

       [:graph:]  Characters  that  are  both printable and visible.  (A space is print‐
                  able, but not visible, while an a is both.)

       [:lower:]  Lowercase alphabetic characters.

       [:print:]  Printable characters (characters that are not control characters.)

       [:punct:]  Punctuation characters (characters that are not letter,  digits,  con‐
                  trol characters, or space characters).

       [:space:]  Space characters (such as space, tab, and formfeed, to name a few).

       [:upper:]  Uppercase alphabetic characters.

       [:xdigit:] Characters that are hexadecimal digits.

       For  example,  before  the  POSIX standard, to match alphanumeric characters, you
       would have had to write /[A-Za-z0-9]/.  If your character set  had  other  alpha‐
       betic characters in it, this would not match them, and if your character set col‐
       lated differently from ASCII, this might not even match  the  ASCII  alphanumeric
       characters.   With  the POSIX character classes, you can write /[[:alnum:]]/, and
       this matches the alphabetic and numeric characters in your character set, no mat‐
       ter what it is.

       Two  additional  special sequences can appear in character lists.  These apply to
       non-ASCII character sets, which can have single symbols  (called  collating  ele‐
       ments)  that  are  represented  with  more than one character, as well as several
       characters that are equivalent for collating, or sorting,  purposes.   (E.g.,  in
       French, a plain “e” and a grave-accented “`” are equivalent.)

       Collating Symbols
              A  collating  symbol is a multi-character collating element enclosed in [.
              and .].  For example, if ch is a collating element, then  [[.ch.]]   is  a
              regular  expression  that  matches this collating element, while [ch] is a
              regular expression that matches either c or h.

       Equivalence Classes
              An equivalence class is a locale-specific name for a  list  of  characters
              that are equivalent.  The name is enclosed in [= and =].  For example, the
              name e might be used to represent all of “e,” “´,” and “`.”  In this case,
              [[=e=]] is a regular expression that matches any of e, ´, or `.

       These  features  are  very valuable in non-English speaking locales.  The library
       functions that gawk uses for regular expression matching currently only recognize
       POSIX  character  classes; they do not recognize collating symbols or equivalence
       classes.

       The \y, \B, \<, \>, \s, \S, \w, \W, \`, and \' operators are  specific  to  gawk;
       they are extensions based on facilities in the GNU regular expression libraries.

       The  various command line options control how gawk interprets characters in regu‐
       lar expressions.

       No options
              In the default case, gawk provide all  the  facilities  of  POSIX  regular
              expressions and the GNU regular expression operators described above.

       --posix
              Only  POSIX  regular  expressions are supported, the GNU operators are not
              special.  (E.g., \w matches a literal w).

       --traditional
              Traditional Unix awk regular expressions are matched.  The  GNU  operators
              are  not  special, and interval expressions are not available.  Characters
              described by octal and hexadecimal escape sequences are treated literally,
              even if they represent regular expression metacharacters.

       --re-interval
              Allow  interval  expressions in regular expressions, even if --traditional
              has been provided.

   Actions
       Action statements are enclosed in braces, { and }.  Action statements consist  of
       the  usual  assignment,  conditional,  and  looping statements found in most lan‐
       guages.  The operators, control statements, and input/output statements available
       are patterned after those in C.

   Operators
       The operators in AWK, in order of decreasing precedence, are

       (...)       Grouping

       $           Field reference.

       ++ --       Increment and decrement, both prefix and postfix.

       ^           Exponentiation (** may also be used, and **= for the assignment oper‐
                   ator).

       + - !       Unary plus, unary minus, and logical negation.

       * / %       Multiplication, division, and modulus.

       + -         Addition and subtraction.

       space       String concatenation.

       |   |&      Piped I/O for getline, print, and printf.

       < > <= >= != ==
                   The regular relational operators.

       ~ !~        Regular expression match, negated match.  NOTE: Do not use a constant
                   regular  expression (/foo/) on the left-hand side of a ~ or !~.  Only
                   use one on the right-hand side.  The expression /foo/ ~ exp  has  the
                   same  meaning  as (($0 ~ /foo/) ~ exp).  This is usually not what was
                   intended.

       in          Array membership.

       &&          Logical AND.

       ||          Logical OR.

       ?:          The C conditional expression.  This has the  form  expr1  ?  expr2  :
                   expr3.   If expr1 is true, the value of the expression is expr2, oth‐
                   erwise it is expr3.  Only one of expr2 and expr3 is evaluated.

       = += -= *= /= %= ^=
                   Assignment.  Both absolute assignment (var  =  value)  and  operator-
                   assignment (the other forms) are supported.

   Control Statements
       The control statements are as follows:

              if (condition) statement [ else statement ]
              while (condition) statement
              do statement while (condition)
              for (expr1; expr2; expr3) statement
              for (var in array) statement
              break
              continue
              delete array[index]
              delete array
              exit [ expression ]
              { statements }
              switch (expression) {
              case value|regex : statement
              ...
              [ default: statement ]
              }

   I/O Statements
       The input/output statements are as follows:

       close(file [, how])   Close  file,  pipe  or co-process.  The optional how should
                             only be used when closing one end of a two-way  pipe  to  a
                             co-process.   It  must  be  a  string value, either "to" or
                             "from".

       getline               Set $0 from next input record; set NF, NR, FNR.

       getline <file         Set $0 from next record of file; set NF.

       getline var           Set var from next input record; set NR, FNR.

       getline var <file     Set var from next record of file.

       command | getline [var]
                             Run command piping the output either into  $0  or  var,  as
                             above.

       command |& getline [var]
                             Run  command  as a co-process piping the output either into
                             $0 or var, as above.  Co-processes are  a  gawk  extension.
                             (command  can also be a socket.  See the subsection Special
                             File Names, below.)

       next                  Stop processing the current input record.  The  next  input
                             record  is  read  and processing starts over with the first
                             pattern in the AWK program.  If the end of the  input  data
                             is reached, the END block(s), if any, are executed.

       nextfile              Stop  processing  the  current  input file.  The next input
                             record read comes from the next input file.   FILENAME  and
                             ARGIND  are  updated,  FNR  is  reset  to 1, and processing
                             starts over with the first pattern in the AWK  program.  If
                             the  end of the input data is reached, the END block(s), if
                             any, are executed.

       print                 Print the current record.  The output record is  terminated
                             with the value of the ORS variable.

       print expr-list       Print  expressions.   Each  expression  is separated by the
                             value of the OFS variable.  The output record is terminated
                             with the value of the ORS variable.

       print expr-list >file Print expressions on file.  Each expression is separated by
                             the value of the OFS variable.  The output record is termi‐
                             nated with the value of the ORS variable.

       printf fmt, expr-list Format and print.  See The printf Statement, below.

       printf fmt, expr-list >file
                             Format and print on file.

       system(cmd-line)      Execute  the  command cmd-line, and return the exit status.
                             (This may not be available on non-POSIX systems.)

       fflush([file])        Flush any buffers associated with the open output  file  or
                             pipe file.  If file is missing or if it is the null string,
                             then flush all open output files and pipes.

       Additional output redirections are allowed for print and printf.

       print ... >> file
              Appends output to the file.

       print ... | command
              Writes on a pipe.

       print ... |& command
              Sends data to a co-process or socket.  (See also  the  subsection  Special
              File Names, below.)

       The  getline  command returns 1 on success, 0 on end of file, and -1 on an error.
       Upon an error, ERRNO contains a string describing the problem.

       NOTE: Failure in opening a two-way socket will result in a non-fatal error  being
       returned  to the calling function. If using a pipe, co-process, or socket to get‐
       line, or from print or printf within a loop, you must use close() to  create  new
       instances  of  the  command  or  socket.  AWK does not automatically close pipes,
       sockets, or co-processes when they return EOF.

   The printf Statement
       The AWK versions of the printf  statement  and  sprintf()  function  (see  below)
       accept the following conversion specification formats:

       %c      A  single  character.   If  the  argument  used  for %c is numeric, it is
               treated as a character and printed.  Otherwise, the argument  is  assumed
               to be a string, and the only first character of that string is printed.

       %d, %i  A decimal number (the integer part).

       %e, %E  A  floating  point  number of the form [-]d.dddddde[+-]dd.  The %E format
               uses E instead of e.

       %f, %F  A floating point number of the form [-]ddd.dddddd.  If the system library
               supports  it,  %F is available as well. This is like %f, but uses capital
               letters for special “not a number” and “infinity” values. If  %F  is  not
               available, gawk uses %f.

       %g, %G  Use  %e or %f conversion, whichever is shorter, with nonsignificant zeros
               suppressed.  The %G format uses %E instead of %e.

       %o      An unsigned octal number (also an integer).

       %u      An unsigned decimal number (again, an integer).

       %s      A character string.

       %x, %X  An unsigned hexadecimal number (an integer).  The %X format  uses  ABCDEF
               instead of abcdef.

       %%      A single % character; no argument is converted.

       Optional, additional parameters may lie between the % and the control letter:

       count$ Use the count'th argument at this point in the formatting.  This is called
              a positional specifier and is intended primarily  for  use  in  translated
              versions  of  format  strings, not in the original text of an AWK program.
              It is a gawk extension.

       -      The expression should be left-justified within its field.

       space  For numeric conversions, prefix positive values with a space, and negative
              values with a minus sign.

       +      The  plus sign, used before the width modifier (see below), says to always
              supply a sign for numeric conversions, even if the data to be formatted is
              positive.  The + overrides the space modifier.

       #      Use  an  “alternate  form”  for certain control letters.  For %o, supply a
              leading zero.  For %x, and %X, supply a leading 0x or  0X  for  a  nonzero
              result.   For  %e,  %E,  %f  and  %F, the result always contains a decimal
              point.  For %g, and %G, trailing zeros are not removed from the result.

       0      A leading 0 (zero) acts as a flag, that indicates output should be  padded
              with  zeroes  instead  of spaces.  This applies only to the numeric output
              formats.  This flag only has an effect when the field width is wider  than
              the value to be printed.

       width  The  field  should  be padded to this width.  The field is normally padded
              with spaces.  If the 0 flag has been used, it is padded with zeroes.

       .prec  A number that specifies the precision to use when printing.  For  the  %e,
              %E,  %f  and  %F,  formats,  this  specifies the number of digits you want
              printed to the right of the decimal point.  For the %g, and %G formats, it
              specifies  the  maximum number of significant digits.  For the %d, %i, %o,
              %u, %x, and %X formats, it specifies  the  minimum  number  of  digits  to
              print.   For  %s,  it  specifies the maximum number of characters from the
              string that should be printed.

       The dynamic width and prec capabilities of the ANSI C printf() routines are  sup‐
       ported.   A  *  in  place of either the width or prec specifications causes their
       values to be taken from the argument list to printf or sprintf().  To use a posi‐
       tional specifier with a dynamic width or precision, supply the count$ after the *
       in the format string.  For example, "%3$*2$.*1$s".

   Special File Names
       When doing I/O redirection from either print or printf into a file, or  via  get‐
       line  from  a  file, gawk recognizes certain special filenames internally.  These
       filenames allow access to open file  descriptors  inherited  from  gawk's  parent
       process  (usually  the  shell).  These file names may also be used on the command
       line to name data files.  The filenames are:

       /dev/stdin  The standard input.

       /dev/stdout The standard output.

       /dev/stderr The standard error output.

       /dev/fd/n   The file associated with the open file descriptor n.

       These are particularly useful for error messages.  For example:

              print "You blew it!" > "/dev/stderr"

       whereas you would otherwise have to use

              print "You blew it!" | "cat 1>&2"

       The following special filenames may be used with the |& co-process  operator  for
       creating TCP/IP network connections:

       /inet/tcp/lport/rhost/rport
       /inet4/tcp/lport/rhost/rport
       /inet6/tcp/lport/rhost/rport
              Files  for a TCP/IP connection on local port lport to remote host rhost on
              remote port rport.  Use a port of 0 to have the system pick a  port.   Use
              /inet4  to  force  an IPv4 connection, and /inet6 to force an IPv6 connec‐
              tion.  Plain /inet uses the system default (most likely IPv4).

       /inet/udp/lport/rhost/rport
       /inet4/udp/lport/rhost/rport
       /inet6/udp/lport/rhost/rport
              Similar, but use UDP/IP instead of TCP/IP.

   Numeric Functions
       AWK has the following built-in arithmetic functions:

       atan2(y, x)   Return the arctangent of y/x in radians.

       cos(expr)     Return the cosine of expr, which is in radians.

       exp(expr)     The exponential function.

       int(expr)     Truncate to integer.

       log(expr)     The natural logarithm function.

       rand()        Return a random number N, between 0 and 1, such that 0 ≤ N < 1.

       sin(expr)     Return the sine of expr, which is in radians.

       sqrt(expr)    The square root function.

       srand([expr]) Use expr as the new seed for the random number  generator.   If  no
                     expr  is  provided,  use  the time of day.  The return value is the
                     previous seed for the random number generator.

   String Functions
       Gawk has the following built-in string functions:

       asort(s [, d [, how] ]) Return the number of elements  in  the  source  array  s.
                               Sort the contents of s using gawk's normal rules for com‐
                               paring values, and replace the indices of the sorted val‐
                               ues  s  with  sequential integers starting with 1. If the
                               optional destination array d  is  specified,  then  first
                               duplicate  s into d, and then sort d, leaving the indices
                               of the source array s unchanged. The optional string  how
                               controls  the  direction  and the comparison mode.  Valid
                               values  for  how  are  any  of  the  strings  valid   for
                               PROCINFO["sorted_in"].   It  can  also  be  the name of a
                               user-defined  comparison   function   as   described   in
                               PROCINFO["sorted_in"].

       asorti(s [, d [, how] ])
                               Return the number of elements in the source array s.  The
                               behavior is the same as that of asort(), except that  the
                               array indices are used for sorting, not the array values.
                               When done, the array is indexed numerically, and the val‐
                               ues are those of the original indices.  The original val‐
                               ues are lost; thus provide a second array if you wish  to
                               preserve  the  original.   The  purpose  of  the optional
                               string how is the same as described in asort() above.

       gensub(r, s, h [, t])   Search the target string t for  matches  of  the  regular
                               expression  r.   If  h is a string beginning with g or G,
                               then replace all matches of r with s.  Otherwise, h is  a
                               number  indicating  which match of r to replace.  If t is
                               not supplied, use $0  instead.   Within  the  replacement
                               text  s, the sequence \n, where n is a digit from 1 to 9,
                               may be used to indicate just the text  that  matched  the
                               n'th parenthesized subexpression.  The sequence \0 repre‐
                               sents the entire matched text, as does the  character  &.
                               Unlike  sub() and gsub(), the modified string is returned
                               as the result of the function, and  the  original  target
                               string is not changed.

       gsub(r, s [, t])        For  each  substring matching the regular expression r in
                               the string t, substitute the string  s,  and  return  the
                               number  of  substitutions.  If t is not supplied, use $0.
                               An & in the replacement text is replaced  with  the  text
                               that  was  actually  matched.  Use \& to get a literal &.
                               (This must be typed as "\\&";  see  GAWK:  Effective  AWK
                               Programming  for a fuller discussion of the rules for &'s
                               and backslashes in the replacement text of sub(), gsub(),
                               and gensub().)

       index(s, t)             Return the index of the string t in the string s, or 0 if
                               t is not present.  (This implies that  character  indices
                               start at one.)

       length([s])             Return the length of the string s, or the length of $0 if
                               s is not supplied.  As a non-standard extension, with  an
                               array  argument,  length() returns the number of elements
                               in the array.

       match(s, r [, a])       Return the position in s where the regular  expression  r
                               occurs,  or  0 if r is not present, and set the values of
                               RSTART and RLENGTH.  Note that the argument order is  the
                               same as for the ~ operator: str ~ re.  If array a is pro‐
                               vided, a is cleared and then elements  1  through  n  are
                               filled  with the portions of s that match the correspond‐
                               ing parenthesized subexpression in r.  The  0'th  element
                               of a contains the portion of s matched by the entire reg‐
                               ular expression r.  Subscripts a[n,  "start"],  and  a[n,
                               "length"]  provide  the  starting index in the string and
                               length respectively, of each matching substring.

       patsplit(s, a [, r [, seps] ])
                               Split the string s into the array a  and  the  separators
                               array  seps  on  the regular expression r, and return the
                               number of fields.  Element values are the portions  of  s
                               that  matched  r.   The value of seps[i] is the separator
                               that appeared in front of a[i+1].  If r is omitted,  FPAT
                               is  used  instead.   The  arrays  a  and seps are cleared
                               first.  Splitting behaves identically to field  splitting
                               with FPAT, described above.

       split(s, a [, r [, seps] ])
                               Split  the  string  s into the array a and the separators
                               array seps on the regular expression r,  and  return  the
                               number  of  fields.  If r is omitted, FS is used instead.
                               The arrays a and seps are cleared first.  seps[i] is  the
                               field separator matched by r between a[i] and a[i+1].  If
                               r is a single space, then leading whitespace  in  s  goes
                               into  the extra array element seps[0] and trailing white‐
                               space goes into the extra array element seps[n], where  n
                               is  the  return value of split(s, a, r, seps).  Splitting
                               behaves identically to field splitting, described above.

       sprintf(fmt, expr-list) Prints  expr-list  according  to  fmt,  and  returns  the
                               resulting string.

       strtonum(str)           Examine str, and return its numeric value.  If str begins
                               with a leading 0, strtonum() assumes that str is an octal
                               number.   If  str  begins  with  a leading 0x or 0X, str‐
                               tonum() assumes that str is a hexadecimal number.  Other‐
                               wise, decimal is assumed.

       sub(r, s [, t])         Just  like  gsub(),  but  replace only the first matching
                               substring.

       substr(s, i [, n])      Return the at most n-character substring of s starting at
                               i.  If n is omitted, use the rest of s.

       tolower(str)            Return  a  copy of the string str, with all the uppercase
                               characters in str translated to their corresponding  low‐
                               ercase  counterparts.  Non-alphabetic characters are left
                               unchanged.

       toupper(str)            Return a copy of the string str, with all  the  lowercase
                               characters  in  str  translated  to  their  corresponding
                               uppercase counterparts.   Non-alphabetic  characters  are
                               left unchanged.

       Gawk is multibyte aware.  This means that index(), length(), substr() and match()
       all work in terms of characters, not bytes.

   Time Functions
       Since one of the primary uses of AWK programs is processing log files  that  con‐
       tain  time stamp information, gawk provides the following functions for obtaining
       time stamps and formatting them.

       mktime(datespec)
                 Turn datespec into a time stamp of the same form as  returned  by  sys‐
                 time(),  and  return  the result.  The datespec is a string of the form
                 YYYY MM DD HH MM SS[ DST].  The contents of the string are six or seven
                 numbers  representing respectively the full year including century, the
                 month from 1 to 12, the day of the month from 1 to 31, the hour of  the
                 day from 0 to 23, the minute from 0 to 59, the second from 0 to 60, and
                 an optional daylight saving flag.  The values of these numbers need not
                 be within the ranges specified; for example, an hour of -1 means 1 hour
                 before midnight.  The origin-zero Gregorian calendar is  assumed,  with
                 year  0  preceding  year  1  and year -1 preceding year 0.  The time is
                 assumed to be in the local timezone.  If the daylight  saving  flag  is
                 positive,  the time is assumed to be daylight saving time; if zero, the
                 time is assumed to be standard time; and  if  negative  (the  default),
                 mktime()  attempts  to  determine  whether  daylight  saving time is in
                 effect for the specified time.  If datespec  does  not  contain  enough
                 elements or if the resulting time is out of range, mktime() returns -1.

       strftime([format [, timestamp[, utc-flag]]])
                 Format timestamp according to the specification in format.  If utc-flag
                 is present and is non-zero or non-null, the result is in UTC, otherwise
                 the  result is in local time.  The timestamp should be of the same form
                 as returned by systime().  If timestamp is missing, the current time of
                 day  is used.  If format is missing, a default format equivalent to the
                 output of  date(1)  is  used.   The  default  format  is  available  in
                 PROCINFO["strftime"].   See  the specification for the strftime() func‐
                 tion in ANSI C for the format conversions that  are  guaranteed  to  be
                 available.

       systime() Return the current time of day as the number of seconds since the Epoch
                 (1970-01-01 00:00:00 UTC on POSIX systems).

   Bit Manipulations Functions
       Gawk supplies the following bit manipulation functions.  They work by  converting
       double-precision  floating  point  values to uintmax_t integers, doing the opera‐
       tion, and then converting the result back to floating point.  The functions are:

       and(v1, v2)         Return the bitwise AND of the values provided by v1 and v2.

       compl(val)          Return the bitwise complement of val.

       lshift(val, count)  Return the value of val, shifted left by count bits.

       or(v1, v2)          Return the bitwise OR of the values provided by v1 and v2.

       rshift(val, count)  Return the value of val, shifted right by count bits.

       xor(v1, v2)         Return the bitwise XOR of the values provided by v1 and v2.

   Type Function
       The following function is for use with multidimensional arrays.

       isarray(x)
              Return true if x is an array, false otherwise.

   Internationalization Functions
       The following functions may be used from within your AWK program for  translating
       strings at run-time.  For full details, see GAWK: Effective AWK Programming.

       bindtextdomain(directory [, domain])
              Specify  the  directory  where  gawk looks for the .mo files, in case they
              will not or cannot be placed in the ``standard'' locations  (e.g.,  during
              testing).  It returns the directory where domain is ``bound.''
              The  default  domain is the value of TEXTDOMAIN.  If directory is the null
              string (""), then bindtextdomain() returns the  current  binding  for  the
              given domain.

       dcgettext(string [, domain [, category]])
              Return the translation of string in text domain domain for locale category
              category.  The default value for domain is the current  value  of  TEXTDO‐
              MAIN.  The default value for category is "LC_MESSAGES".
              If  you  supply  a value for category, it must be a string equal to one of
              the known locale categories described in GAWK: Effective AWK  Programming.
              You must also supply a text domain.  Use TEXTDOMAIN if you want to use the
              current domain.

       dcngettext(string1 , string2 , number [, domain [, category]])
              Return the plural form used for number of the translation of  string1  and
              string2  in  text domain domain for locale category category.  The default
              value for domain is the current value of TEXTDOMAIN.   The  default  value
              for category is "LC_MESSAGES".
              If  you  supply  a value for category, it must be a string equal to one of
              the known locale categories described in GAWK: Effective AWK  Programming.
              You must also supply a text domain.  Use TEXTDOMAIN if you want to use the
              current domain.

USER-DEFINED FUNCTIONS
       Functions in AWK are defined as follows:

              function name(parameter list) { statements }

       Functions are executed when they are called from  within  expressions  in  either
       patterns or actions.  Actual parameters supplied in the function call are used to
       instantiate the formal parameters declared in the function.  Arrays are passed by
       reference, other variables are passed by value.

       Since  functions  were not originally part of the AWK language, the provision for
       local variables is rather clumsy: They are declared as extra  parameters  in  the
       parameter  list.  The convention is to separate local variables from real parame‐
       ters by extra spaces in the parameter list.  For example:

              function  f(p, q,     a, b)   # a and b are local
              {
                   ...
              }

              /abc/     { ... ; f(1, 2) ; ... }

       The left parenthesis in a function call is required  to  immediately  follow  the
       function name, without any intervening whitespace.  This avoids a syntactic ambi‐
       guity with the concatenation operator.  This restriction does not  apply  to  the
       built-in functions listed above.

       Functions  may call each other and may be recursive.  Function parameters used as
       local variables are initialized to the null string and the number zero upon func‐
       tion invocation.

       Use return expr to return a value from a function.  The return value is undefined
       if no value is provided, or if the function returns by “falling off” the end.

       As a gawk extension, functions may be called indirectly. To do this,  assign  the
       name  of  the  function  to  be called, as a string, to a variable.  Then use the
       variable as if it were the name of a function, prefixed with an @ sign, like so:
              function  myfunc()
              {
                   print "myfunc called"
                   ...
              }

              {    ...
                   the_func = "myfunc"
                   @the_func()    # call through the_func to myfunc
                   ...
              }

       If --lint has been provided, gawk warns about calls  to  undefined  functions  at
       parse time, instead of at run time.  Calling an undefined function at run time is
       a fatal error.

       The word func may be used in place of function.

DYNAMICALLY LOADING NEW FUNCTIONS
       You can dynamically add new built-in functions to the running  gawk  interpreter.
       The  full  details  are beyond the scope of this manual page; see GAWK: Effective
       AWK Programming for the details.

       extension(object, function)
               Dynamically link the shared object file named by object, and invoke func‐
               tion  in  that  object,  to perform initialization.  These should both be
               provided as strings.  Return the value returned by function.

       Using this feature at the C level is not pretty, but it is unlikely to  go  away.
       Additional mechanisms may be added at some point.

SIGNALS
       pgawk accepts two signals.  SIGUSR1 causes it to dump a profile and function call
       stack to the profile file, which is either  awkprof.out,  or  whatever  file  was
       named  with the --profile option.  It then continues to run.  SIGHUP causes pgawk
       to dump the profile and function call stack and then exit.

INTERNATIONALIZATION
       String constants are sequences of characters enclosed in double quotes.  In  non-
       English  speaking environments, it is possible to mark strings in the AWK program
       as requiring translation to the local natural language. Such strings  are  marked
       in the AWK program with a leading underscore (“_”).  For example,

              gawk 'BEGIN { print "hello, world" }'

       always prints hello, world.  But,

              gawk 'BEGIN { print _"hello, world" }'

       might print bonjour, monde in France.

       There  are several steps involved in producing and running a localizable AWK pro‐
       gram.

       1.  Add a BEGIN action to assign a value to the TEXTDOMAIN variable  to  set  the
           text domain to a name associated with your program:

           BEGIN { TEXTDOMAIN = "myprog" }

       This allows gawk to find the .mo file associated with your program.  Without this
       step, gawk uses the messages text domain, which likely does not contain  transla‐
       tions for your program.

       2.  Mark all strings that should be translated with leading underscores.

       3.  If  necessary,  use the dcgettext() and/or bindtextdomain() functions in your
           program, as appropriate.

       4.  Run gawk --gen-pot -f myprog.awk > myprog.pot to generate a .po file for your
           program.

       5.  Provide appropriate translations, and build and install the corresponding .mo
           files.

       The internationalization features are described in full detail in GAWK: Effective
       AWK Programming.

POSIX COMPATIBILITY
       A primary goal for gawk is compatibility with the POSIX standard, as well as with
       the latest version of UNIX awk.  To this end,  gawk  incorporates  the  following
       user  visible  features  which are not described in the AWK book, but are part of
       the Bell Laboratories version of awk, and are in the POSIX standard.

       The book indicates that command line variable assignment happens when  awk  would
       otherwise  open  the  argument  as a file, which is after the BEGIN block is exe‐
       cuted.  However, in earlier implementations, when  such  an  assignment  appeared
       before  any  file  names,  the assignment would happen before the BEGIN block was
       run.  Applications came to depend on this “feature.”  When  awk  was  changed  to
       match  its  documentation,  the  -v option for assigning variables before program
       execution was added to accommodate applications that depended upon the old behav‐
       ior.   (This  feature  was  agreed upon by both the Bell Laboratories and the GNU
       developers.)

       When processing arguments, gawk uses the special option “--” to signal the end of
       arguments.  In compatibility mode, it warns about but otherwise ignores undefined
       options.  In normal operation, such arguments are passed on to  the  AWK  program
       for it to process.

       The AWK book does not define the return value of srand().  The POSIX standard has
       it return the seed it  was  using,  to  allow  keeping  track  of  random  number
       sequences.  Therefore srand() in gawk also returns its current seed.

       Other  new features are: The use of multiple -f options (from MKS awk); the ENVI‐
       RON array; the \a, and \v escape sequences (done originally in gawk and fed  back
       into  the  Bell Laboratories version); the tolower() and toupper() built-in func‐
       tions (from the Bell Laboratories version); and the ANSI C conversion  specifica‐
       tions in printf (done first in the Bell Laboratories version).

HISTORICAL FEATURES
       There  is one feature of historical AWK implementations that gawk supports: It is
       possible to call the length() built-in function not only with  no  argument,  but
       even without parentheses!  Thus,

              a = length     # Holy Algol 60, Batman!

       is the same as either of

              a = length()
              a = length($0)

       Using  this  feature is poor practice, and gawk issues a warning about its use if
       --lint is specified on the command line.

GNU EXTENSIONS
       Gawk has a number of extensions to POSIX awk.  They are described  in  this  sec‐
       tion.   All  the  extensions described here can be disabled by invoking gawk with
       the --traditional or --posix options.

       The following features of gawk are not available in POSIX awk.

       · No path search is performed for files named via the -f option.   Therefore  the
         AWKPATH environment variable is not special.

       · There is no facility for doing file inclusion (gawk's @include mechanism).

       · The \x escape sequence.  (Disabled with --posix.)

       · The ability to continue lines after ?  and :.  (Disabled with --posix.)

       · Octal and hexadecimal constants in AWK programs.

       · The ARGIND, BINMODE, ERRNO, LINT, RT and TEXTDOMAIN variables are not special.

       · The IGNORECASE variable and its side-effects are not available.

       · The FIELDWIDTHS variable and fixed-width field splitting.

       · The FPAT variable and field splitting based on field values.

       · The PROCINFO array is not available.

       · The use of RS as a regular expression.

       · The special file names available for I/O redirection are not recognized.

       · The |& operator for creating co-processes.

       · The BEGINFILE and ENDFILE special patterns are not available.

       · The  ability  to  split  out individual characters using the null string as the
         value of FS, and as the third argument to split().

       · An optional fourth argument to split() to receive the separator texts.

       · The optional second argument to the close() function.

       · The optional third argument to the match() function.

       · The ability to use positional specifiers with printf and sprintf().

       · The ability to pass an array to length().

       · The use of delete array to delete the entire contents of an array.

       · The use of nextfile to abandon processing of the current input file.

       · The and(), asort(), asorti(), bindtextdomain(), compl(),  dcgettext(),  dcnget‐
         text(),  gensub(),  lshift(), mktime(), or(), patsplit(), rshift(), strftime(),
         strtonum(), systime() and xor() functions.

       · Localizable strings.

       · Adding new built-in functions dynamically with the extension() function.

       The AWK book does not define the return value of the  close()  function.   Gawk's
       close()  returns  the  value from fclose(3), or pclose(3), when closing an output
       file or pipe, respectively.  It returns the process's exit status when closing an
       input pipe.  The return value is -1 if the named file, pipe or co-process was not
       opened with a redirection.

       When gawk is invoked with the --traditional option, if the fs argument to the  -F
       option  is  “t”, then FS is set to the tab character.  Note that typing gawk -F\t
       ...  simply causes the shell to quote the “t,” and does not pass “\t” to  the  -F
       option.   Since  this is a rather ugly special case, it is not the default behav‐
       ior.  This behavior also does not occur if --posix has been specified.  To really
       get a tab character as the field separator, it is best to use single quotes: gawk
       -F'\t' ....

ENVIRONMENT VARIABLES
       The AWKPATH environment variable can be used to provide  a  list  of  directories
       that gawk searches when looking for files named via the -f and --file options.

       For  socket  communication, two special environment variables can be used to con‐
       trol the number of retries (GAWK_SOCK_RETRIES), and the interval between  retries
       (GAWK_MSEC_SLEEP).   The interval is in milliseconds. On systems that do not sup‐
       port usleep(3), the value is rounded up to an integral number of seconds.

       If POSIXLY_CORRECT exists in the environment, then gawk  behaves  exactly  as  if
       --posix  had  been  specified on the command line.  If --lint has been specified,
       gawk issues a warning message to this effect.

EXIT STATUS
       If the exit statement is used with a value, then  gawk  exits  with  the  numeric
       value given to it.

       Otherwise,  if there were no problems during execution, gawk exits with the value
       of the C constant EXIT_SUCCESS.  This is usually zero.

       If an error occurs, gawk exits with the value of  the  C  constant  EXIT_FAILURE.
       This is usually one.

       If  gawk exits because of a fatal error, the exit status is 2.  On non-POSIX sys‐
       tems, this value may be mapped to EXIT_FAILURE.

VERSION INFORMATION
       This man page documents gawk, version 4.0.

AUTHORS
       The original version of UNIX awk was designed  and  implemented  by  Alfred  Aho,
       Peter Weinberger, and Brian Kernighan of Bell Laboratories.  Brian Kernighan con‐
       tinues to maintain and enhance it.

       Paul Rubin and Jay Fenlason, of the Free Software Foundation, wrote gawk,  to  be
       compatible  with the original version of awk distributed in Seventh Edition UNIX.
       John Woods contributed a number of bug fixes.  David Trueman, with  contributions
       from  Arnold  Robbins,  made  gawk  compatible  with the new version of UNIX awk.
       Arnold Robbins is the current maintainer.

       The initial DOS port was done by Conrad Kwok and Scott Garfinkle.   Scott  Deifik
       maintains  the  port  to MS-DOS using DJGPP.  Eli Zaretskii maintains the port to
       MS-Windows using MinGW.  Pat Rankin did the port to VMS,  and  Michal  Jaegermann
       did  the port to the Atari ST.  The port to OS/2 was done by Kai Uwe Rommel, with
       contributions and help from Darrel Hankerson.  Andreas Buening now maintains  the
       OS/2  port.   The late Fred Fish supplied support for the Amiga, and Martin Brown
       provided the BeOS port.  Stephen Davies provided the original  Tandem  port,  and
       Matthew  Woehlke  provided  changes  for  Tandem's POSIX-compliant systems.  Dave
       Pitts provided the port to z/OS.

       See the README file in the gawk distribution  for  up-to-date  information  about
       maintainers and which ports are currently supported.

BUG REPORTS
       If  you  find  a  bug  in  gawk, please send electronic mail to bug-gawk@gnu.org.
       Please include your operating system and its revision, the version of gawk  (from
       gawk  --version), which C compiler you used to compile it, and a test program and
       data that are as small as possible for reproducing the problem.

       Before sending a bug report, please do the following things.  First, verify  that
       you  have  the latest version of gawk.  Many bugs (usually subtle ones) are fixed
       at each release, and if yours is out of date, the problem may already  have  been
       solved.   Second,  please  see  if  setting  the  environment  variable LC_ALL to
       LC_ALL=C causes things to behave as you expect. If so, it's a locale  issue,  and
       may  or may not really be a bug.  Finally, please read this man page and the ref‐
       erence manual carefully to be sure that what  you  think  is  a  bug  really  is,
       instead of just a quirk in the language.

       Whatever  you  do,  do  NOT  post  a bug report in comp.lang.awk.  While the gawk
       developers occasionally read this newsgroup, posting  bug  reports  there  is  an
       unreliable way to report bugs.  Instead, please use the electronic mail addresses
       given above.

       If you're using a GNU/Linux or BSD-based system, you may wish  to  submit  a  bug
       report  to  the vendor of your distribution.  That's fine, but please send a copy
       to the official email address as well, since there's no guarantee  that  the  bug
       report will be forwarded to the gawk maintainer.

BUGS
       The  -F  option  is not necessary given the command line variable assignment fea‐
       ture; it remains only for backwards compatibility.

       Syntactically invalid single character programs tend to overflow the parse stack,
       generating  a rather unhelpful message.  Such programs are surprisingly difficult
       to diagnose in the completely general case, and the effort to do so really is not
       worth it.

SEE ALSO
       egrep(1),  getpid(2),  getppid(2),  getpgrp(2), getuid(2), geteuid(2), getgid(2),
       getegid(2), getgroups(2), usleep(3)

       The AWK Programming Language, Alfred V. Aho, Brian W. Kernighan, Peter  J.  Wein‐
       berger, Addison-Wesley, 1988.  ISBN 0-201-07981-X.

       GAWK:  Effective AWK Programming, Edition 4.0, shipped with the gawk source.  The
       current version of this document is available online at  http://www.gnu.org/soft‐
       ware/gawk/manual.

EXAMPLES
       Print and sort the login names of all users:

            BEGIN     { FS = ":" }
                 { print $1 | "sort" }

       Count lines in a file:

                 { nlines++ }
            END  { print nlines }

       Precede each line by its number in the file:

            { print FNR, $0 }

       Concatenate and line number (a variation on a theme):

            { print NR, $0 }

       Run an external command for particular lines of data:

            tail -f access_log |
            awk '/myhome.html/ { system("nmap " $1 ">> logdir/myhome.html") }'

ACKNOWLEDGEMENTS
       Brian  Kernighan of Bell Laboratories provided valuable assistance during testing
       and debugging.  We thank him.

COPYING PERMISSIONS
       Copyright © 1989, 1991, 1992, 1993, 1994, 1995, 1996,  1997,  1998,  1999,  2001,
       2002, 2003, 2004, 2005, 2007, 2009, 2010, 2011 Free Software Foundation, Inc.

       Permission  is granted to make and distribute verbatim copies of this manual page
       provided the copyright notice and this permission notice  are  preserved  on  all
       copies.

       Permission  is  granted  to  copy and distribute modified versions of this manual
       page under the conditions for verbatim copying, provided that the entire  result‐
       ing  derived work is distributed under the terms of a permission notice identical
       to this one.

       Permission is granted to copy and distribute translations  of  this  manual  page
       into  another  language, under the above conditions for modified versions, except
       that this permission notice may be stated in a translation approved by the  Foun‐
       dation.



Free Software Foundation               Dec 07 2012                               GAWK(1)
SORT(1)                               User Commands                              SORT(1)



NAME
       sort - sort lines of text files

SYNOPSIS
       sort [OPTION]... [FILE]...
       sort [OPTION]... --files0-from=F

DESCRIPTION
       Write sorted concatenation of all FILE(s) to standard output.

       Mandatory  arguments to long options are mandatory for short options too.  Order‐
       ing options:

       -b, --ignore-leading-blanks
              ignore leading blanks

       -d, --dictionary-order
              consider only blanks and alphanumeric characters

       -f, --ignore-case
              fold lower case to upper case characters

       -g, --general-numeric-sort
              compare according to general numerical value

       -i, --ignore-nonprinting
              consider only printable characters

       -M, --month-sort
              compare (unknown) < 'JAN' < ... < 'DEC'

       -h, --human-numeric-sort
              compare human readable numbers (e.g., 2K 1G)

       -n, --numeric-sort
              compare according to string numerical value

       -R, --random-sort
              sort by random hash of keys

       --random-source=FILE
              get random bytes from FILE

       -r, --reverse
              reverse the result of comparisons

       --sort=WORD
              sort according to WORD: general-numeric -g, human-numeric  -h,  month  -M,
              numeric -n, random -R, version -V

       -V, --version-sort
              natural sort of (version) numbers within text

       Other options:

       --batch-size=NMERGE
              merge at most NMERGE inputs at once; for more use temp files

       -c, --check, --check=diagnose-first
              check for sorted input; do not sort

       -C, --check=quiet, --check=silent
              like -c, but do not report first bad line

       --compress-program=PROG
              compress temporaries with PROG; decompress them with PROG -d

       --debug
              annotate  the  part  of the line used to sort, and warn about questionable
              usage to stderr

       --files0-from=F
              read input from the files specified by NUL-terminated names in file F;  If
              F is - then read names from standard input

       -k, --key=KEYDEF
              sort via a key; KEYDEF gives location and type

       -m, --merge
              merge already sorted files; do not sort

       -o, --output=FILE
              write result to FILE instead of standard output

       -s, --stable
              stabilize sort by disabling last-resort comparison

       -S, --buffer-size=SIZE
              use SIZE for main memory buffer

       -t, --field-separator=SEP
              use SEP instead of non-blank to blank transition

       -T, --temporary-directory=DIR
              use  DIR  for  temporaries,  not $TMPDIR or /tmp; multiple options specify
              multiple directories

       --parallel=N
              change the number of sorts run concurrently to N

       -u, --unique
              with -c, check for strict ordering; without -c, output only the  first  of
              an equal run

       -z, --zero-terminated
              end lines with 0 byte, not newline

       --help display this help and exit

       --version
              output version information and exit

       KEYDEF  is  F[.C][OPTS][,F[.C][OPTS]]  for  start and stop position, where F is a
       field number and C a character position in the field; both are origin 1, and  the
       stop  position  defaults  to  the line's end.  If neither -t nor -b is in effect,
       characters in a field are counted from the beginning of the preceding whitespace.
       OPTS  is one or more single-letter ordering options [bdfgiMhnRrV], which override
       global ordering options for that key.  If no key is given, use the entire line as
       the key.

       SIZE  may be followed by the following multiplicative suffixes: % 1% of memory, b
       1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.

       With no FILE, or when FILE is -, read standard input.

       *** WARNING *** The locale specified by the environment affects sort order.   Set
       LC_ALL=C to get the traditional sort order that uses native byte values.

       GNU  coreutils  online help: <http://www.gnu.org/software/coreutils/> Report sort
       translation bugs to <http://translationproject.org/team/>

AUTHOR
       Written by Mike Haertel and Paul Eggert.

COPYRIGHT
       Copyright © 2013 Free Software Foundation, Inc.  License GPLv3+: GNU GPL  version
       3 or later <http://gnu.org/licenses/gpl.html>.
       This  is  free software: you are free to change and redistribute it.  There is NO
       WARRANTY, to the extent permitted by law.

SEE ALSO
       uniq(1)

       The full documentation for sort is maintained as a Texinfo manual.  If  the  info
       and sort programs are properly installed at your site, the command

              info coreutils 'sort invocation'

       should give you access to the complete manual.



GNU coreutils 8.22                    November 2020                              SORT(1)
TAR(1)                                User Commands                               TAR(1)



NAME
       tar - manual page for tar 1.26

SYNOPSIS
       tar [OPTION...] [FILE]...

DESCRIPTION
       GNU  `tar'  saves many files together into a single tape or disk archive, and can
       restore individual files from the archive.

       Note that this manual page contains just very brief description (or more  like  a
       list  of  possible  functionality)  originally generated by the help2man utility.
       The full documentation for tar is maintained as a Texinfo manual.   If  the  info
       and  tar  programs  are  properly  installed at your site, the command `info tar'
       should give you access to the complete manual.

EXAMPLES
       tar -cf archive.tar foo bar
              # Create archive.tar from files foo and bar.

       tar -tvf archive.tar
              # List all files in archive.tar verbosely.

       tar -xf archive.tar
              # Extract all files from archive.tar.

DEFAULTS
       *This* tar installation defaults to:

       --format=gnu -f- -b20 --quoting-style=escape  --rmt-command=/sbin/rmt  --rsh-com‐
       mand=/usr/bin/rsh

Main operation mode:
       -A, --catenate, --concatenate
              append tar files to an archive

       -c, --create
              create a new archive

       -d, --diff, --compare
              find differences between archive and file system

       --delete
              delete from the archive (not on mag tapes!)

       -r, --append
              append files to the end of an archive

       -t, --list
              list the contents of an archive

       --test-label
              test the archive volume label and exit

       -u, --update
              only append files newer than copy in archive

       -x, --extract, --get
              extract files from an archive

Common options:
       -C, --directory=DIR
              change to directory DIR

       -f, --file=ARCHIVE
              use archive file or device ARCHIVE

       -j, --bzip2
              filter the archive through bzip2

        -J, --xz
              filter the archive through xz

       -p, --preserve-permissions
              extract  information  about  file permissions (default for superuser)

       -v, --verbose
              verbosely list files processed

       -z, --gzip
              filter the archive through gzip


Operation modifiers:
       --check-device
              check device numbers when creating incremental archives (default)

       -g, --listed-incremental=FILE
              handle new GNU-format incremental backup

       -G, --incremental
              handle old GNU-format incremental backup

       --ignore-failed-read
              do not exit with nonzero on unreadable files

       --level=NUMBER
              dump level for created listed-incremental archive

       -n, --seek
              archive is seekable

       --no-check-device
              do not check device numbers when creating incremental archives

       --no-seek
              archive is not seekable

       --occurrence[=NUMBER]
              process  only  the  NUMBERth  occurrence of each file in the archive; this
              option is valid only in conjunction with one of the subcommands  --delete,
              --diff,  --extract  or  --list and when a list of files is given either on
              the command line or via the -T option; NUMBER defaults to 1

       --sparse-version=MAJOR[.MINOR]
              set version of the sparse format to use (implies --sparse)

       -S, --sparse
              handle sparse files efficiently

Overwrite control:
       -k, --keep-old-files
              don't replace existing files when extracting, treat them as errors

       --keep-newer-files
              don't replace existing files that are newer than their archive copies

       --keep-directory-symlink
              Don't replace existing symlinks to directories when extracting.

       --no-overwrite-dir
              preserve metadata of existing directories

       --overwrite
              overwrite existing files when extracting

       --overwrite-dir
              overwrite metadata of existing directories when extracting (default)

       --recursive-unlink
              empty hierarchies prior to extracting directory

       --remove-files
              remove files after adding them to the archive

       --skip-old-files
              don't replace existing files when extracting, silently skip over them

       -U, --unlink-first
              remove each file prior to extracting over it

       -W, --verify
              attempt to verify the archive after writing it

Select output stream:
       --ignore-command-error ignore exit codes of children

       --no-ignore-command-error
              treat non-zero exit codes of children as error

       -O, --to-stdout
              extract files to standard output

       --to-command=COMMAND
              pipe extracted files to another program

Handling of file attributes:
       --atime-preserve[=METHOD]
              preserve access times on dumped files, either by restoring the times after
              reading  (METHOD='replace';  default)  or  by not setting the times in the
              first place (METHOD='system')

       --delay-directory-restore
              delay setting modification times and permissions of extracted  directories
              until the end of extraction

       --group=NAME
              force NAME as group for added files

       --mode=CHANGES
              force (symbolic) mode CHANGES for added files

       --mtime=DATE-OR-FILE
              set mtime for added files from DATE-OR-FILE

       -m, --touch
              don't extract file modified time

       --no-delay-directory-restore
              cancel the effect of --delay-directory-restore option

       --no-same-owner
              extract files as yourself (default for ordinary users)

       --no-same-permissions
              apply  the  user's  umask  when  extracting  permissions  from the archive
              (default for ordinary users)

       --numeric-owner
              always use numbers for user/group names

       --owner=NAME
              force NAME as owner for added files

       -p, --preserve-permissions, --same-permissions
              extract information about file permissions (default for superuser)

       --preserve
              same as both -p and -s

       --same-owner
              try extracting files with the same ownership  as  exists  in  the  archive
              (default for superuser)

       -s, --preserve-order, --same-order
              sort names to extract to match archive

Handling of extended file attributes:
       --acls Enable the POSIX ACLs support

       --no-acls
              Disable the POSIX ACLs support

       --no-selinux
              Disable the SELinux context support

       --no-xattrs
              Disable extended attributes support

       --selinux
              Enable the SELinux context support

       --xattrs
              Enable extended attributes support

       --xattrs-exclude=MASK
              specify the exclude pattern for xattr keys

       --xattrs-include=MASK
              specify the include pattern for xattr keys

Device selection and switching:
       -f, --file=ARCHIVE
              use archive file or device ARCHIVE

       --force-local
              archive file is local even if it has a colon

       -F, --info-script=NAME, --new-volume-script=NAME
              run script at end of each tape (implies -M)

       -L, --tape-length=NUMBER
              change tape after writing NUMBER x 1024 bytes

       -M, --multi-volume
              create/list/extract multi-volume archive

       --rmt-command=COMMAND
              use given rmt COMMAND instead of rmt

       --rsh-command=COMMAND
              use remote COMMAND instead of rsh

       --volno-file=FILE
              use/update the volume number in FILE

Device blocking:
       -b, --blocking-factor=BLOCKS
              BLOCKS x 512 bytes per record

       -B, --read-full-records
              reblock as we read (for 4.2BSD pipes)

       -i, --ignore-zeros
              ignore zeroed blocks in archive (means EOF)

       --record-size=NUMBER
              NUMBER of bytes per record, multiple of 512

Archive format selection:
       -H, --format=FORMAT
              create archive of the given format

              FORMAT is one of the following:

                     gnu    GNU tar 1.13.x format

                     oldgnu GNU format as per tar <= 1.12

                     pax    POSIX 1003.1-2001 (pax) format

                     posix  same as pax

                     ustar  POSIX 1003.1-1988 (ustar) format

                     v7     old V7 tar format

       --old-archive, --portability
              same as --format=v7

       --pax-option=keyword[[:]=value][,keyword[[:]=value]]...
              control pax keywords

       --posix
              same as --format=posix

       -V, --label=TEXT
              create  archive with volume name TEXT; at list/extract time, use TEXT as a
              globbing pattern for volume name

Compression options:
       -a, --auto-compress
              use archive suffix to determine the compression program

       -I, --use-compress-program=PROG
              filter through PROG (must accept -d)

       -j, --bzip2
              filter the archive through bzip2

       -J, --xz
              filter the archive through xz

       --lzip filter the archive through lzip

       --lzma filter the archive through lzma

       --lzop

       --no-auto-compress
              do not use archive suffix to determine the compression program

       -z, --gzip, --gunzip, --ungzip
              filter the archive through gzip

       -Z, --compress, --uncompress
              filter the archive through compress

       Note: You might need to install external program (lzip/ncompress/lzma...) to  use
       some of these compression options

Local file selection:
       --add-file=FILE
              add given FILE to the archive (useful if its name starts with a dash)

       --backup[=CONTROL]
              backup before removal, choose version CONTROL

       -C, --directory=DIR
              change to directory DIR

       --exclude=PATTERN
              exclude files, given as a PATTERN

       --exclude-backups
              exclude backup and lock files

       --exclude-caches
              exclude  contents  of  directories containing CACHEDIR.TAG, except for the
              tag file itself

       --exclude-caches-all
              exclude directories containing CACHEDIR.TAG

       --exclude-caches-under exclude everything under directories containing
              CACHEDIR.TAG

       --exclude-tag=FILE
              exclude contents of directories containing FILE, except for FILE itself

       --exclude-tag-all=FILE exclude directories containing FILE

       --exclude-tag-under=FILE
              exclude everything under directories containing FILE

       --exclude-vcs
              exclude version control system directories

       -h, --dereference
              follow symlinks; archive and dump the files they point to

       --hard-dereference
              follow hard links; archive and dump the files they refer to

       -K, --starting-file=MEMBER-NAME
              begin at member MEMBER-NAME in the archive

       --newer-mtime=DATE
              compare date and time when data changed only

       --no-null
              disable the effect of the previous --null option

       --no-recursion
              avoid descending automatically in directories

       --no-unquote
              do not unquote filenames read with -T

       --null                 -T reads null-terminated names, disable -C

       -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE
              only store files newer than DATE-OR-FILE

       --one-file-system
              stay in local file system when creating archive

       -P, --absolute-names
              don't strip leading `/'s from file names

       --recursion
              recurse into directories (default)

       --suffix=STRING
              backup before removal, override usual suffix  ('~'  unless  overridden  by
              environment variable SIMPLE_BACKUP_SUFFIX)

       -T, --files-from=FILE
              get names to extract or create from FILE

       --unquote
              unquote filenames read with -T (default)

       -X, --exclude-from=FILE
              exclude patterns listed in FILE

File name transformations:
       --strip-components=NUMBER
              strip NUMBER leading components from file names on extraction

       --transform=EXPRESSION, --xform=EXPRESSION
              use sed replace EXPRESSION to transform file names

              File name matching options (affect both exclude and include patterns):

       --anchored
              patterns match file name start

       --ignore-case
              ignore case

       --no-anchored
              patterns match after any `/' (default for exclusion)

       --no-ignore-case
              case sensitive matching (default)

       --no-wildcards
              verbatim string matching

       --no-wildcards-match-slash
              wildcards do not match `/'

       --wildcards
              use wildcards (default)

       --wildcards-match-slash
              wildcards match `/' (default for exclusion)

Informative output:
       --checkpoint[=NUMBER]
              display progress messages every NUMBERth record (default 10)

       --checkpoint-action=ACTION
              execute ACTION on each checkpoint

       --full-time
              print file time to its full resolution

       --index-file=FILE
              send verbose output to FILE

       -l, --check-links
              print a message if not all links are dumped

       --no-quote-chars=STRING
              disable quoting for characters from STRING

       --quote-chars=STRING
              additionally quote characters from STRING

       --quoting-style=STYLE
              set name quoting style; see below for valid STYLE values

       -R, --block-number
              show block number within archive with each message

       --show-defaults
              show tar defaults

       --show-omitted-dirs
              when listing or extracting, list each directory that does not match search
              criteria

       --show-transformed-names, --show-stored-names
              show file or archive names after transformation

       --totals[=SIGNAL]
              print total bytes after processing the archive; with an argument  -  print
              total  bytes  when  this SIGNAL is delivered; Allowed signals are: SIGHUP,
              SIGQUIT, SIGINT, SIGUSR1 and SIGUSR2; the names  without  SIG  prefix  are
              also accepted

       --utc  print file modification dates in UTC

       -v, --verbose
              verbosely list files processed

       --warning=KEYWORD
              warning control

       -w, --interactive, --confirmation
              ask for confirmation for every action

Compatibility options:
       -o     when   creating,   same   as   --old-archive;  when  extracting,  same  as
              --no-same-owner

Other options:
       -?, --help
              give this help list

       --restrict
              disable use of some potentially harmful options

       --usage
              give a short usage message

       --version
              print program version

       Mandatory or optional arguments to long options are also  mandatory  or  optional
       for any corresponding short options.

       The  backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.  The
       version control may be set with --backup or VERSION_CONTROL, values are:

       none, off
              never make backups

       t, numbered
              make numbered backups

       nil, existing
              numbered if numbered backups exist, simple otherwise

       never, simple
              always make simple backups

       Valid arguments for the --quoting-style option are:

              literal shell shell-always c c-maybe escape locale clocale

AUTHOR
       Written by John Gilmore and Jay Fenlason.

REPORTING BUGS
       Report bugs to <bug-tar@gnu.org>.

COPYRIGHT
       Copyright © 2013 Free Software Foundation, Inc.  License GPLv3+: GNU GPL  version
       3 or later <http://gnu.org/licenses/gpl.html>.
       This  is  free software: you are free to change and redistribute it.  There is NO
       WARRANTY, to the extent permitted by law.



tar 1.26                              February 2013                               TAR(1)
FIND(1)                          General Commands Manual                         FIND(1)



NAME
       find - search for files in a directory hierarchy

SYNOPSIS
       find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]

DESCRIPTION
       This manual page documents the GNU version of find.  GNU find searches the direc‐
       tory tree rooted at each given file name by evaluating the given expression  from
       left  to  right,  according  to  the rules of precedence (see section OPERATORS),
       until the outcome is known (the left hand side is false for and operations,  true
       for or), at which point find moves on to the next file name.

       If  you are using find in an environment where security is important (for example
       if you are using it to search directories that are writable by other users),  you
       should read the "Security Considerations" chapter of the findutils documentation,
       which is called Finding Files and comes  with  findutils.    That  document  also
       includes  a lot more detail and discussion than this manual page, so you may find
       it a more useful source of information.

OPTIONS
       The -H, -L and -P options control the treatment of symbolic links.   Command-line
       arguments  following  these  are  taken to be names of files or directories to be
       examined, up to the first argument that begins with `-', or the argument  `('  or
       `!'.   That  argument  and any following arguments are taken to be the expression
       describing what is to be searched for.  If no paths are given, the current direc‐
       tory  is used.  If no expression is given, the expression -print is used (but you
       should probably consider using -print0 instead, anyway).

       This manual page talks about `options' within the expression list.  These options
       control  the  behaviour of find but are specified immediately after the last path
       name.  The five `real' options -H, -L, -P, -D and -O must appear before the first
       path  name,  if  at  all.   A  double dash -- can also be used to signal that any
       remaining arguments are not options (though ensuring that all start points  begin
       with  either  `./'  or `/' is generally safer if you use wildcards in the list of
       start points).

       -P     Never follow symbolic links.  This is the default  behaviour.   When  find
              examines  or  prints  information a file, and the file is a symbolic link,
              the information used shall be taken from the properties  of  the  symbolic
              link itself.


       -L     Follow  symbolic  links.   When  find examines or prints information about
              files, the information used shall be taken from the properties of the file
              to  which the link points, not from the link itself (unless it is a broken
              symbolic link or find is unable to examine the  file  to  which  the  link
              points).   Use  of  this  option implies -noleaf.  If you later use the -P
              option, -noleaf will still be in effect.  If -L is in effect and find dis‐
              covers  a symbolic link to a subdirectory during its search, the subdirec‐
              tory pointed to by the symbolic link will be searched.

              When the -L option is in effect, the -type  predicate  will  always  match
              against  the  type  of the file that a symbolic link points to rather than
              the link itself (unless the symbolic link is broken).  Using -L causes the
              -lname and -ilname predicates always to return false.


       -H     Do  not  follow  symbolic  links, except while processing the command line
              arguments.  When find examines or  prints  information  about  files,  the
              information  used  shall be taken from the properties of the symbolic link
              itself.   The only exception to this behaviour is when a file specified on
              the  command  line  is a symbolic link, and the link can be resolved.  For
              that situation, the information used  is  taken  from  whatever  the  link
              points to (that is, the link is followed).  The information about the link
              itself is used as a fallback if the file pointed to by the  symbolic  link
              cannot  be examined.  If -H is in effect and one of the paths specified on
              the command line is a symbolic link to a directory, the contents  of  that
              directory  will  be  examined  (though of course -maxdepth 0 would prevent
              this).

       If more than one of -H, -L and -P is specified, each overrides  the  others;  the
       last  one  appearing  on the command line takes effect.  Since it is the default,
       the -P option should be considered to be in effect unless  either  -H  or  -L  is
       specified.

       GNU find frequently stats files during the processing of the command line itself,
       before any searching has begun.  These options also affect  how  those  arguments
       are  processed.   Specifically,  there  are  a number of tests that compare files
       listed on the command line against a file we are currently considering.  In  each
       case,  the file specified on the command line will have been examined and some of
       its properties will have been saved.  If the named file is  in  fact  a  symbolic
       link,  and  the  -P option is in effect (or if neither -H nor -L were specified),
       the information used for the comparison will be taken from the properties of  the
       symbolic  link.   Otherwise, it will be taken from the properties of the file the
       link points to.  If find cannot follow the  link  (for  example  because  it  has
       insufficient  privileges or the link points to a nonexistent file) the properties
       of the link itself will be used.

       When the -H or -L options are in effect, any symbolic links listed as  the  argu‐
       ment  of  -newer  will  be dereferenced, and the timestamp will be taken from the
       file to which the symbolic link points.  The same consideration applies to  -new‐
       erXY, -anewer and -cnewer.

       The  -follow  option  has  a  similar effect to -L, though it takes effect at the
       point where it appears (that is, if -L is not used but -follow is,  any  symbolic
       links appearing after -follow on the command line will be dereferenced, and those
       before it will not).


       -D debugoptions
              Print diagnostic information; this can be  helpful  to  diagnose  problems
              with  why  find  is  not  doing  what you want.  The list of debug options
              should be comma separated.  Compatibility of  the  debug  options  is  not
              guaranteed  between  releases  of findutils.  For a complete list of valid
              debug options, see the output  of  find  -D  help.   Valid  debug  options
              include

              help   Explain the debugging options

              tree   Show the expression tree in its original and optimised form.

              stat   Print messages as files are examined with the stat and lstat system
                     calls.  The find program tries to minimise such calls.

              opt    Prints diagnostic information relating to the optimisation  of  the
                     expression tree; see the -O option.

              rates  Prints  a  summary indicating how often each predicate succeeded or
                     failed.

       -Olevel
              Enables query optimisation.   The find program reorders tests to speed  up
              execution  while  preserving  the overall effect; that is, predicates with
              side effects are not reordered relative to each other.  The  optimisations
              performed at each optimisation level are as follows.

              0      Equivalent to optimisation level 1.

              1      This  is the default optimisation level and corresponds to the tra‐
                     ditional behaviour.  Expressions are reordered so that tests  based
                     only  on the names of files (for example -name and -regex) are per‐
                     formed first.

              2      Any -type or -xtype tests are performed after any tests based  only
                     on  the  names of files, but before any tests that require informa‐
                     tion from the inode.  On many modern versions of Unix,  file  types
                     are  returned  by  readdir()  and so these predicates are faster to
                     evaluate than predicates which need to stat the file first.  If you
                     use  the  -fstype  FOO  predicate  and specify a filsystem type FOO
                     which is not known (that is, present in `/etc/mtab')  at  the  time
                     find starts, that predicate is equivalent to -false.

              3      At  this optimisation level, the full cost-based query optimiser is
                     enabled.  The order of tests is modified so that cheap (i.e.  fast)
                     tests  are  performed  first  and more expensive ones are performed
                     later, if necessary.  Within each cost band, predicates are  evalu‐
                     ated  earlier or later according to whether they are likely to suc‐
                     ceed or not.  For -o, predicates which are likely  to  succeed  are
                     evaluated  earlier, and for -a, predicates which are likely to fail
                     are evaluated earlier.

              The cost-based optimiser has a fixed idea of how likely any given test  is
              to  succeed.   In some cases the probability takes account of the specific
              nature of the test (for example, -type f is assumed to be more  likely  to
              succeed than -type c).  The cost-based optimiser is currently being evalu‐
              ated.   If it does not actually improve the performance of find,  it  will
              be  removed  again.   Conversely, optimisations that prove to be reliable,
              robust and effective may be enabled  at  lower  optimisation  levels  over
              time.  However, the default behaviour (i.e. optimisation level 1) will not
              be changed in the 4.3.x release series.  The findutils test suite runs all
              the  tests  on find at each optimisation level and ensures that the result
              is the same.

EXPRESSIONS
       The expression is made up of options (which affect overall operation rather  than
       the processing of a specific file, and always return true), tests (which return a
       true or false value), and actions (which have side effects and return a  true  or
       false  value), all separated by operators.  -and is assumed where the operator is
       omitted.

       If the expression contains no actions other than -prune, -print is  performed  on
       all files for which the expression is true.


   OPTIONS
       All  options  always  return true.  Except for -daystart, -follow and -regextype,
       the options affect all tests, including tests specified before the option.   This
       is  because  the options are processed when the command line is parsed, while the
       tests don't do anything until files are examined.   The  -daystart,  -follow  and
       -regextype  options  are  different  in  this respect, and have an effect only on
       tests which appear later in the command line.  Therefore, for clarity, it is best
       to  place  them  at  the beginning of the expression.  A warning is issued if you
       don't do this.


       -d     A synonym for -depth, for compatibility with FreeBSD, NetBSD, MacOS X  and
              OpenBSD.


       -daystart
              Measure  times  (for -amin, -atime, -cmin, -ctime, -mmin, and -mtime) from
              the beginning of today rather than from 24 hours ago.   This  option  only
              affects tests which appear later on the command line.


       -depth Process  each  directory's  contents  before  the  directory  itself.  The
              -delete action also implies -depth.


       -follow
              Deprecated; use  the  -L  option  instead.   Dereference  symbolic  links.
              Implies -noleaf.  The -follow option affects only those tests which appear
              after it on the command line.  Unless the -H or -L option has been  speci‐
              fied,  the  position  of  the  -follow option changes the behaviour of the
              -newer predicate; any files listed as  the  argument  of  -newer  will  be
              dereferenced  if  they are symbolic links.  The same consideration applies
              to -newerXY, -anewer and -cnewer.  Similarly,  the  -type  predicate  will
              always  match  against the type of the file that a symbolic link points to
              rather than the link itself.  Using -follow causes the -lname and  -ilname
              predicates always to return false.


       -help, --help
              Print a summary of the command-line usage of find and exit.


       -ignore_readdir_race
              Normally,  find  will  emit an error message when it fails to stat a file.
              If you give this option and a file is deleted between the time find  reads
              the  name of the file from the directory and the time it tries to stat the
              file, no error message will be issued.    This also applies  to  files  or
              directories  whose names are given on the command line.  This option takes
              effect at the time the command line is read, which means that  you  cannot
              search  one part of the filesystem with this option on and part of it with
              this option off (if you need to do that, you will need to issue  two  find
              commands instead, one with the option and one without it).


       -maxdepth levels
              Descend  at  most  levels  (a  non-negative integer) levels of directories
              below the command line arguments.  -maxdepth 0
               means only apply the tests and actions to the command line arguments.


       -mindepth levels
              Do not apply any tests or actions at levels less than levels (a  non-nega‐
              tive  integer).   -mindepth  1  means process all files except the command
              line arguments.


       -mount Don't descend directories on other filesystems.   An  alternate  name  for
              -xdev, for compatibility with some other versions of find.


       -noignore_readdir_race
              Turns off the effect of -ignore_readdir_race.


       -noleaf
              Do  not  optimize by assuming that directories contain 2 fewer subdirecto‐
              ries than their hard link count.  This option  is  needed  when  searching
              filesystems that do not follow the Unix directory-link convention, such as
              CD-ROM or MS-DOS filesystems or AFS volume mount points.   Each  directory
              on  a  normal  Unix filesystem has at least 2 hard links: its name and its
              `.'  entry.  Additionally, its subdirectories (if any) each  have  a  `..'
              entry linked to that directory.  When find is examining a directory, after
              it has statted 2 fewer subdirectories than the directory's link count,  it
              knows  that  the  rest of the entries in the directory are non-directories
              (`leaf' files in the directory tree).  If only the files' names need to be
              examined, there is no need to stat them; this gives a significant increase
              in search speed.


       -regextype type
              Changes the regular expression syntax understood  by  -regex  and  -iregex
              tests  which occur later on the command line.  Currently-implemented types
              are emacs (this is the default), posix-awk, posix-basic,  posix-egrep  and
              posix-extended.


       -version, --version
              Print the find version number and exit.


       -warn, -nowarn
              Turn warning messages on or off.  These warnings apply only to the command
              line usage, not to any  conditions  that  find  might  encounter  when  it
              searches directories.  The default behaviour corresponds to -warn if stan‐
              dard input is a tty, and to -nowarn otherwise.


       -xautofs
              Don't descend directories on autofs filesystems.


       -xdev  Don't descend directories on other filesystems.


   TESTS
       Some tests, for example -newerXY and -samefile, allow comparison between the file
       currently  being  examined and some reference file specified on the command line.
       When these tests are used, the interpretation of the reference file is determined
       by  the options -H, -L and -P and any previous -follow, but the reference file is
       only examined once, at the time the command line is  parsed.   If  the  reference
       file  cannot  be examined (for example, the stat(2) system call fails for it), an
       error message is issued, and find exits with a nonzero status.

       Numeric arguments can be specified as

       +n     for greater than n,

       -n     for less than n,

       n      for exactly n.

       -amin n
              File was last accessed n minutes ago.


       -anewer file
              File was last accessed more recently than file was modified.  If file is a
              symbolic  link and the -H option or the -L option is in effect, the access
              time of the file it points to is always used.


       -atime n
              File was last accessed n*24 hours ago.  When find  figures  out  how  many
              24-hour  periods  ago  the  file was last accessed, any fractional part is
              ignored, so to match -atime +1, a file has to have been accessed at  least
              two days ago.


       -cmin n
              File's status was last changed n minutes ago.


       -cnewer file
              File's  status  was last changed more recently than file was modified.  If
              file is a symbolic link and the -H option or the -L option is  in  effect,
              the status-change time of the file it points to is always used.


       -ctime n
              File's  status  was  last  changed  n*24  hours ago.  See the comments for
              -atime to understand how rounding affects the interpretation of file  sta‐
              tus change times.


       -empty File is empty and is either a regular file or a directory.


       -executable
              Matches  files  which  are executable and directories which are searchable
              (in a file name resolution sense).  This takes into account access control
              lists  and other permissions artefacts which the -perm test ignores.  This
              test makes use of the access(2) system call, and so can be fooled  by  NFS
              servers  which  do  UID  mapping  (or  root-squashing), since many systems
              implement access(2) in the client's kernel and so cannot make use  of  the
              UID  mapping  information  held on the server.  Because this test is based
              only on the result of the access(2) system call,  there  is  no  guarantee
              that a file for which this test succeeds can actually be executed.


       -false Always false.


       -fstype type
              File  is  on  a  filesystem of type type.  The valid filesystem types vary
              among different versions of Unix; an incomplete list of  filesystem  types
              that  are  accepted  on some version of Unix or another is: ufs, 4.2, 4.3,
              nfs, tmp, mfs, S51K, S52K.  You can use -printf with the %F  directive  to
              see the types of your filesystems.


       -gid n File's numeric group ID is n.


       -group gname
              File belongs to group gname (numeric group ID allowed).


       -ilname pattern
              Like  -lname,  but the match is case insensitive.  If the -L option or the
              -follow option is in effect, this test returns false unless  the  symbolic
              link is broken.



       -iname pattern
              Like  -name, but the match is case insensitive.  For example, the patterns
              `fo*' and `F??' match the file names  `Foo',  `FOO',  `foo',  `fOo',  etc.
              The pattern `*foo*` will also match a file called '.foobar'.


       -inum n
              File  has inode number n.  It is normally easier to use the -samefile test
              instead.


       -ipath pattern
              Like -path.  but the match is case insensitive.


       -iregex pattern
              Like -regex, but the match is case insensitive.


       -iwholename pattern
              See -ipath.    This alternative is less portable than -ipath.


       -links n
              File has n links.


       -lname pattern
              File is a symbolic link whose contents match shell pattern  pattern.   The
              metacharacters do not treat `/' or `.' specially.  If the -L option or the
              -follow option is in effect, this test returns false unless  the  symbolic
              link is broken.


       -mmin n
              File's data was last modified n minutes ago.


       -mtime n
              File's data was last modified n*24 hours ago.  See the comments for -atime
              to understand how rounding affects the interpretation of file modification
              times.


       -name pattern
              Base  of file name (the path with the leading directories removed) matches
              shell pattern pattern.  Because the leading directories are  removed,  the
              file  names  considered for a match with -name will never include a slash,
              so `-name a/b' will never match anything (you probably need to  use  -path
              instead).   The  metacharacters  (`*',  `?',  and `[]') match a `.' at the
              start of the base name (this is a change in findutils-4.2.2;  see  section
              STANDARDS  CONFORMANCE  below).  To ignore a directory and the files under
              it, use -prune; see an example in the description of  -path.   Braces  are
              not recognised as being special, despite the fact that some shells includ‐
              ing Bash imbue braces with a special meaning in shell patterns.  The file‐
              name  matching  is  performed with the use of the fnmatch(3) library func‐
              tion.   Don't forget to enclose the pattern in quotes in order to  protect
              it from expansion by the shell.


       -newer file
              File was modified more recently than file.  If file is a symbolic link and
              the -H option or the -L option is in effect, the modification time of  the
              file it points to is always used.


       -newerXY reference
              Compares  the timestamp of the current file with reference.  The reference
              argument is normally the name of a file (and one of its timestamps is used
              for  the  comparison)  but  it may also be a string describing an absolute
              time.  X and Y are placeholders  for  other  letters,  and  these  letters
              select which time belonging to how reference is used for the comparison.

              a   The access time of the file reference
              B   The birth time of the file reference
              c   The inode status change time of reference
              m   The modification time of the file reference
              t   reference is interpreted directly as a time

              Some  combinations  are invalid; for example, it is invalid for X to be t.
              Some combinations are not implemented on all systems; for example B is not
              supported  on all systems.  If an invalid or unsupported combination of XY
              is specified, a fatal error results.  Time specifications are  interpreted
              as  for  the argument to the -d option of GNU date.  If you try to use the
              birth time of a reference file, and the birth time cannot be determined, a
              fatal  error  message  results.  If you specify a test which refers to the
              birth time of files being examined, this test  will  fail  for  any  files
              where the birth time is unknown.


       -nogroup
              No group corresponds to file's numeric group ID.


       -nouser
              No user corresponds to file's numeric user ID.


       -path pattern
              File  name matches shell pattern pattern.  The metacharacters do not treat
              `/' or `.' specially; so, for example,
                        find . -path "./sr*sc"
              will print an entry for a directory called `./src/misc' (if  one  exists).
              To  ignore  a  whole directory tree, use -prune rather than checking every
              file in the tree.  For example, to skip the directory `src/emacs' and  all
              files  and  directories  under  it, and print the names of the other files
              found, do something like this:
                        find . -path ./src/emacs -prune -o -print
              Note that the pattern match test applies to the whole file name,  starting
              from  one  of  the  start points named on the command line.  It would only
              make sense to use an absolute path name here if the relevant  start  point
              is  also  an absolute path.  This means that this command will never match
              anything:
                        find bar -path /foo/bar/myfile -print
              Find compares the -path argument with the  concatenation  of  a  directory
              name  and  the base name of the file it's examining.  Since the concatena‐
              tion will never end with a slash, -path arguments ending in a  slash  will
              match  nothing  (except  perhaps  a  start  point specified on the command
              line).  The predicate -path is also supported by HP-UX find and will be in
              a forthcoming version of the POSIX standard.


       -perm mode
              File's  permission  bits  are  exactly mode (octal or symbolic).  Since an
              exact match is required, if you want to use this form for symbolic  modes,
              you  may have to specify a rather complex mode string.  For example `-perm
              g=w' will only match files which have mode 0020 (that is, ones  for  which
              group  write  permission  is  the only permission set).  It is more likely
              that you will want to use the `/' or `-' forms, for example `-perm  -g=w',
              which matches any file with group write permission.  See the EXAMPLES sec‐
              tion for some illustrative examples.


       -perm -mode
              All of the permission bits mode are set for the file.  Symbolic modes  are
              accepted  in this form, and this is usually the way in which would want to
              use them.  You must specify `u', `g' or `o' if you use  a  symbolic  mode.
              See the EXAMPLES section for some illustrative examples.


       -perm /mode
              Any  of the permission bits mode are set for the file.  Symbolic modes are
              accepted in this form.  You must specify `u', `g' or `o' if you use a sym‐
              bolic  mode.  See the EXAMPLES section for some illustrative examples.  If
              no permission bits in mode are set, this test matches any file  (the  idea
              here is to be consistent with the behaviour of -perm -000).


       -perm +mode
              Deprecated, old way of searching for files with any of the permission bits
              in mode set.  You should use -perm /mode instead. Trying to  use  the  `+'
              syntax  with  symbolic  modes will yield surprising results.  For example,
              `+u+x' is a valid symbolic mode (equivalent to +u,+x, i.e. 0111) and  will
              therefore  not  be  evaluated as -perm +mode but instead as the exact mode
              specifier -perm mode and so it matches files with exact  permissions  0111
              instead  of  files  with any execute bit set.  If you found this paragraph
              confusing, you're not alone - just use -perm  /mode.   This  form  of  the
              -perm  test  is  deprecated  because  the POSIX specification requires the
              interpretation of a leading `+' as being part of a symbolic mode,  and  so
              we switched to using `/' instead.


       -readable
              Matches  files which are readable.  This takes into account access control
              lists and other permissions artefacts which the -perm test ignores.   This
              test  makes  use of the access(2) system call, and so can be fooled by NFS
              servers which do UID  mapping  (or  root-squashing),  since  many  systems
              implement  access(2)  in the client's kernel and so cannot make use of the
              UID mapping information held on the server.


       -regex pattern
              File name matches regular expression pattern.  This  is  a  match  on  the
              whole  path, not a search.  For example, to match a file named `./fubar3',
              you can use the regular expression `.*bar.' or `.*b.*3', but not  `f.*r3'.
              The  regular  expressions  understood by find are by default Emacs Regular
              Expressions, but this can be changed with the -regextype option.


       -samefile name
              File refers to the same inode as name.   When -L is in  effect,  this  can
              include symbolic links.


       -size n[cwbkMG]
              File uses n units of space.  The following suffixes can be used:

              `b'    for 512-byte blocks (this is the default if no suffix is used)

              `c'    for bytes

              `w'    for two-byte words

              `k'    for Kilobytes (units of 1024 bytes)

              `M'    for Megabytes (units of 1048576 bytes)

              `G'    for Gigabytes (units of 1073741824 bytes)

              The  size  does  not  count  indirect  blocks, but it does count blocks in
              sparse files that are not actually allocated.  Bear in mind that the  `%k'
              and  `%b'  format  specifiers  of -printf handle sparse files differently.
              The `b' suffix always denotes 512-byte blocks and never 1 Kilobyte blocks,
              which is different to the behaviour of -ls.


       -true  Always true.


       -type c
              File is of type c:

              b      block (buffered) special

              c      character (unbuffered) special

              d      directory

              p      named pipe (FIFO)

              f      regular file

              l      symbolic  link;  this is never true if the -L option or the -follow
                     option is in effect, unless the symbolic link is  broken.   If  you
                     want to search for symbolic links when -L is in effect, use -xtype.

              s      socket

              D      door (Solaris)

       -uid n File's numeric user ID is n.


       -used n
              File was last accessed n days after its status was last changed.


       -user uname
              File is owned by user uname (numeric user ID allowed).


       -wholename pattern
              See -path.    This alternative is less portable than -path.


       -writable
              Matches  files which are writable.  This takes into account access control
              lists and other permissions artefacts which the -perm test ignores.   This
              test  makes  use of the access(2) system call, and so can be fooled by NFS
              servers which do UID  mapping  (or  root-squashing),  since  many  systems
              implement  access(2)  in the client's kernel and so cannot make use of the
              UID mapping information held on the server.


       -xtype c
              The same as -type unless the file is a symbolic link.  For symbolic links:
              if the -H or -P option was specified, true if the file is a link to a file
              of type c; if the -L option has been given, true if c is  `l'.   In  other
              words,  for  symbolic links, -xtype checks the type of the file that -type
              does not check.

       -context pattern
              (SELinux only) Security context of the file matches glob pattern.


   ACTIONS
       -delete
              Delete files; true if removal succeeded.  If the removal failed, an  error
              message  is  issued.  If -delete fails, find's exit status will be nonzero
              (when it eventually exits).  Use of -delete  automatically  turns  on  the
              `-depth' option.

              Warnings:  Don't  forget  that  the  find  command line is evaluated as an
              expression, so putting -delete first will make find try to  delete  every‐
              thing  below  the starting points you specified.  When testing a find com‐
              mand line that you later intend to use with -delete, you should explicitly
              specify -depth in order to avoid later surprises.  Because -delete implies
              -depth, you cannot usefully use -prune and -delete together.


       -exec command ;
              Execute command; true if 0 status is returned.  All following arguments to
              find are taken to be arguments to the command until an argument consisting
              of `;' is encountered.  The string `{}' is replaced by  the  current  file
              name being processed everywhere it occurs in the arguments to the command,
              not just in arguments where it is alone, as  in  some  versions  of  find.
              Both  of  these  constructions  might  need  to be escaped (with a `\') or
              quoted to protect them from expansion by the shell.  See the EXAMPLES sec‐
              tion  for  examples of the use of the -exec option.  The specified command
              is run once for each matched file.  The command is executed in the  start‐
              ing  directory.    There are unavoidable security problems surrounding use
              of the -exec action; you should use the -execdir option instead.


       -exec command {} +
              This variant of the  -exec  action  runs  the  specified  command  on  the
              selected  files,  but the command line is built by appending each selected
              file name at the end; the total number of invocations of the command  will
              be  much less than the number of matched files.  The command line is built
              in much the same way that  xargs  builds  its  command  lines.   Only  one
              instance  of  `{}' is allowed within the command.  The command is executed
              in the starting directory.


       -execdir command ;

       -execdir command {} +
              Like -exec, but the specified command is run from  the  subdirectory  con‐
              taining the matched file, which is not normally the directory in which you
              started find.  This a much more secure method for invoking commands, as it
              avoids  race  conditions  during  resolution  of  the paths to the matched
              files.  As with the -exec action, the `+' form of -execdir  will  build  a
              command  line to process more than one matched file, but any given invoca‐
              tion of command will only list files that exist in the same  subdirectory.
              If  you use this option, you must ensure that your $PATH environment vari‐
              able does not reference `.'; otherwise, an attacker can run  any  commands
              they  like  by leaving an appropriately-named file in a directory in which
              you will run -execdir.  The same applies to having entries in $PATH  which
              are empty or which are not absolute directory names.


       -fls file
              True;  like -ls but write to file like -fprint.  The output file is always
              created, even if the predicate is never matched.  See  the  UNUSUAL  FILE‐
              NAMES  section  for  information about how unusual characters in filenames
              are handled.


       -fprint file
              True; print the full file name into file file.  If  file  does  not  exist
              when  find  is run, it is created; if it does exist, it is truncated.  The
              file names `/dev/stdout' and `/dev/stderr'  are  handled  specially;  they
              refer to the standard output and standard error output, respectively.  The
              output file is always created, even if the  predicate  is  never  matched.
              See  the UNUSUAL FILENAMES section for information about how unusual char‐
              acters in filenames are handled.


       -fprint0 file
              True; like -print0 but write to file like -fprint.   The  output  file  is
              always  created,  even if the predicate is never matched.  See the UNUSUAL
              FILENAMES section for information about how unusual  characters  in  file‐
              names are handled.


       -fprintf file format
              True;  like  -printf  but  write to file like -fprint.  The output file is
              always created, even if the predicate is never matched.  See  the  UNUSUAL
              FILENAMES  section  for  information about how unusual characters in file‐
              names are handled.


       -ls    True; list current file in ls -dils format on standard output.  The  block
              counts  are  of 1K blocks, unless the environment variable POSIXLY_CORRECT
              is set, in which case 512-byte blocks are used.  See the UNUSUAL FILENAMES
              section for information about how unusual characters in filenames are han‐
              dled.


       -ok command ;
              Like -exec but ask the user first.  If the user agrees, run  the  command.
              Otherwise just return false.  If the command is run, its standard input is
              redirected from /dev/null.


              The response to the prompt is matched against a pair  of  regular  expres‐
              sions  to  determine  if  it is an affirmative or negative response.  This
              regular expression is obtained from the system  if  the  `POSIXLY_CORRECT'
              environment  variable  is  set,  or otherwise from find's message transla‐
              tions.  If the system has no suitable definition,  find's  own  definition
              will  be used.   In either case, the interpretation of the regular expres‐
              sion itself will be  affected  by  the  environment  variables  'LC_CTYPE'
              (character  classes)  and  'LC_COLLATE'  (character ranges and equivalence
              classes).




       -okdir command ;
              Like -execdir but ask the user first in the same way as for -ok.   If  the
              user  does not agree, just return false.  If the command is run, its stan‐
              dard input is redirected from /dev/null.


       -print True; print the full file name on the standard output, followed by a  new‐
              line.    If  you  are  piping  the output of find into another program and
              there is the faintest possibility that the files which you  are  searching
              for  might contain a newline, then you should seriously consider using the
              -print0 option instead of -print.  See the UNUSUAL FILENAMES  section  for
              information about how unusual characters in filenames are handled.


       -print0
              True;  print the full file name on the standard output, followed by a null
              character (instead of the  newline  character  that  -print  uses).   This
              allows  file  names that contain newlines or other types of white space to
              be correctly interpreted by programs that process the find  output.   This
              option corresponds to the -0 option of xargs.


       -printf format
              True;  print  format  on the standard output, interpreting `\' escapes and
              `%' directives.  Field widths and precisions can be specified as with  the
              `printf'  C  function.  Please note that many of the fields are printed as
              %s rather than %d, and this may mean that flags don't work  as  you  might
              expect.   This also means that the `-' flag does work (it forces fields to
              be left-aligned).  Unlike -print, -printf does not add a  newline  at  the
              end of the string.  The escapes and directives are:

              \a     Alarm bell.

              \b     Backspace.

              \c     Stop printing from this format immediately and flush the output.

              \f     Form feed.

              \n     Newline.

              \r     Carriage return.

              \t     Horizontal tab.

              \v     Vertical tab.

              \0     ASCII NUL.

              \\     A literal backslash (`\').

              \NNN   The character whose ASCII code is NNN (octal).

              A  `\' character followed by any other character is treated as an ordinary
              character, so they both are printed.

              %%     A literal percent sign.

              %a     File's last access time in the format returned  by  the  C  `ctime'
                     function.

              %Ak    File's  last  access  time  in  the format specified by k, which is
                     either `@' or a directive for the C `strftime' function.  The  pos‐
                     sible  values  for  k  are  listed below; some of them might not be
                     available on all systems, due to differences in `strftime'  between
                     systems.

                     @      seconds since Jan. 1, 1970, 00:00 GMT, with fractional part.

                     Time fields:

                     H      hour (00..23)

                     I      hour (01..12)

                     k      hour ( 0..23)

                     l      hour ( 1..12)

                     M      minute (00..59)

                     p      locale's AM or PM

                     r      time, 12-hour (hh:mm:ss [AP]M)

                     S      Second (00.00 .. 61.00).  There is a fractional part.

                     T      time, 24-hour (hh:mm:ss)

                     +      Date    and    time,   separated   by   `+',   for   example
                            `2004-04-28+22:22:05.0'.  This is a GNU extension.  The time
                            is  given  in the current timezone (which may be affected by
                            setting the TZ environment  variable).   The  seconds  field
                            includes a fractional part.

                     X      locale's time representation (H:M:S)

                     Z      time  zone (e.g., EDT), or nothing if no time zone is deter‐
                            minable

                     Date fields:

                     a      locale's abbreviated weekday name (Sun..Sat)

                     A      locale's full weekday name, variable length  (Sunday..Satur‐
                            day)

                     b      locale's abbreviated month name (Jan..Dec)

                     B      locale's  full  month name, variable length (January..Decem‐
                            ber)

                     c      locale's date and time (Sat Nov 04 12:02:33 EST 1989).   The
                            format  is  the same as for ctime(3) and so to preserve com‐
                            patibility with that format, there is no fractional part  in
                            the seconds field.

                     d      day of month (01..31)

                     D      date (mm/dd/yy)

                     h      same as b

                     j      day of year (001..366)

                     m      month (01..12)

                     U      week  number  of  year  with  Sunday  as  first  day of week
                            (00..53)

                     w      day of week (0..6)

                     W      week number of  year  with  Monday  as  first  day  of  week
                            (00..53)

                     x      locale's date representation (mm/dd/yy)

                     y      last two digits of year (00..99)

                     Y      year (1970...)

              %b     The  amount  of  disk  space used for this file in 512-byte blocks.
                     Since disk space is allocated in multiples of the filesystem  block
                     size  this  is  usually  greater  than  %s/512,  but it can also be
                     smaller if the file is a sparse file.

              %c     File's last status change time in the  format  returned  by  the  C
                     `ctime' function.

              %Ck    File's  last status change time in the format specified by k, which
                     is the same as for %A.

              %d     File's depth in the directory tree; 0 means the file is  a  command
                     line argument.

              %D     The  device  number  on  which the file exists (the st_dev field of
                     struct stat), in decimal.

              %f     File's name with any leading directories  removed  (only  the  last
                     element).

              %F     Type  of  the filesystem the file is on; this value can be used for
                     -fstype.

              %g     File's group name, or numeric group ID if the group has no name.

              %G     File's numeric group ID.

              %h     Leading directories of file's name (all but the last element).   If
                     the  file  name  contains  no  slashes  (since it is in the current
                     directory) the %h specifier expands to ".".

              %H     Command line argument under which file was found.

              %i     File's inode number (in decimal).

              %k     The amount of disk space used for this file  in  1K  blocks.  Since
                     disk  space  is allocated in multiples of the filesystem block size
                     this is usually greater than %s/1024, but it can also be smaller if
                     the file is a sparse file.

              %l     Object  of  symbolic  link  (empty string if file is not a symbolic
                     link).

              %m     File's permission bits (in octal).  This option  uses  the  `tradi‐
                     tional'  numbers  which  most Unix implementations use, but if your
                     particular implementation uses an unusual ordering of octal permis‐
                     sions  bits,  you will see a difference between the actual value of
                     the file's mode and the output of %m.   Normally you will  want  to
                     have  a leading zero on this number, and to do this, you should use
                     the # flag (as in, for example, `%#m').

              %M     File's permissions (in symbolic form, as for ls).   This  directive
                     is supported in findutils 4.2.5 and later.

              %n     Number of hard links to file.

              %p     File's name.

              %P     File's  name with the name of the command line argument under which
                     it was found removed.

              %s     File's size in bytes.

              %S     File's sparseness.  This is calculated  as  (BLOCKSIZE*st_blocks  /
                     st_size).   The  exact value you will get for an ordinary file of a
                     certain length is system-dependent.  However, normally sparse files
                     will have values less than 1.0, and files which use indirect blocks
                     may have a value which is greater than 1.0.   The  value  used  for
                     BLOCKSIZE  is  system-dependent, but is usually 512 bytes.   If the
                     file size is zero, the value  printed  is  undefined.   On  systems
                     which lack support for st_blocks, a file's sparseness is assumed to
                     be 1.0.

              %t     File's last modification time in  the  format  returned  by  the  C
                     `ctime' function.

              %Tk    File's  last  modification time in the format specified by k, which
                     is the same as for %A.

              %u     File's user name, or numeric user ID if the user has no name.

              %U     File's numeric user ID.

              %y     File's type (like in ls -l), U=unknown type (shouldn't happen)

              %Y     File's type (like %y), plus follow symlinks: L=loop, N=nonexistent

              %Z     (SELinux only) file's security context.

              %{ %[ %(
                     Reserved for future use.

              A `%' character followed by any other  character  is  discarded,  but  the
              other  character is printed (don't rely on this, as further format charac‐
              ters may be introduced).  A `%' at the end of the format  argument  causes
              undefined  behaviour  since  there  is  no  following  character.  In some
              locales, it may hide your door keys, while in others  it  may  remove  the
              final page from the novel you are reading.

              The  %m  and  %d  directives  support the # , 0 and + flags, but the other
              directives do not, even if they print numbers.  Numeric directives that do
              not  support these flags include G, U, b, D, k and n.  The `-' format flag
              is supported and changes the alignment of  a  field  from  right-justified
              (which is the default) to left-justified.

              See  the UNUSUAL FILENAMES section for information about how unusual char‐
              acters in filenames are handled.



       -prune True; if the file is a directory, do not descend into  it.  If  -depth  is
              given,  false; no effect.  Because -delete implies -depth, you cannot use‐
              fully use -prune and -delete together.


       -quit  Exit immediately.  No child processes will be left running,  but  no  more
              paths  specified on the command line will be processed.  For example, find
              /tmp/foo /tmp/bar -print -quit will  print  only  /tmp/foo.   Any  command
              lines  which  have  been  built  up with -execdir ... {} + will be invoked
              before find exits.   The exit status may or may not be zero, depending  on
              whether an error has already occurred.


   UNUSUAL FILENAMES
       Many  of  the  actions  of find result in the printing of data which is under the
       control of other users.  This includes file names, sizes, modification times  and
       so  forth.  File names are a potential problem since they can contain any charac‐
       ter except `\0' and `/'.  Unusual characters in file names can do unexpected  and
       often  undesirable things to your terminal (for example, changing the settings of
       your function keys on some terminals).  Unusual characters  are  handled  differ‐
       ently by various actions, as described below.


       -print0, -fprint0
              Always print the exact filename, unchanged, even if the output is going to
              a terminal.


       -ls, -fls
              Unusual characters are always escaped.  White space, backslash, and double
              quote  characters  are  printed  using C-style escaping (for example `\f',
              `\"').  Other unusual characters are printed using an octal escape.  Other
              printable  characters  (for  -ls and -fls these are the characters between
              octal 041 and 0176) are printed as-is.


       -printf, -fprintf
              If the output is not going to a terminal, it is printed as-is.  Otherwise,
              the  result  depends on which directive is in use.  The directives %D, %F,
              %g, %G, %H, %Y, and %y expand to values which are  not  under  control  of
              files'  owners,  and so are printed as-is.  The directives %a, %b, %c, %d,
              %i, %k, %m, %M, %n, %s, %t, %u and %U have values which are under the con‐
              trol  of  files' owners but which cannot be used to send arbitrary data to
              the terminal, and so these are printed as-is.  The directives %f, %h,  %l,
              %p  and  %P  are quoted.  This quoting is performed in the same way as for
              GNU ls.  This is not the same quoting mechanism as the one  used  for  -ls
              and  -fls.  If you are able to decide what format to use for the output of
              find then it is normally better to use `\0' as a terminator  than  to  use
              newline,  as  file  names  can contain white space and newline characters.
              The setting of the `LC_CTYPE' environment variable is  used  to  determine
              which characters need to be quoted.


       -print, -fprint
              Quoting  is  handled  in the same way as for -printf and -fprintf.  If you
              are using find in a script or in a situation where the matched files might
              have arbitrary names, you should consider using -print0 instead of -print.

       The  -ok and -okdir actions print the current filename as-is.  This may change in
       a future release.


   OPERATORS
       Listed in order of decreasing precedence:


       ( expr )
              Force precedence.  Since parentheses are special to the  shell,  you  will
              normally need to quote them.  Many of the examples in this manual page use
              backslashes for this purpose: `\(...\)' instead of `(...)'.


       ! expr True if expr is false.  This character will also usually  need  protection
              from interpretation by the shell.


       -not expr
              Same as ! expr, but not POSIX compliant.


       expr1 expr2
              Two  expressions  in  a  row are taken to be joined with an implied "and";
              expr2 is not evaluated if expr1 is false.


       expr1 -a expr2
              Same as expr1 expr2.


       expr1 -and expr2
              Same as expr1 expr2, but not POSIX compliant.


       expr1 -o expr2
              Or; expr2 is not evaluated if expr1 is true.


       expr1 -or expr2
              Same as expr1 -o expr2, but not POSIX compliant.


       expr1 , expr2
              List; both expr1 and expr2 are always evaluated.  The value  of  expr1  is
              discarded; the value of the list is the value of expr2. The comma operator
              can be useful for searching for several  different  types  of  thing,  but
              traversing the filesystem hierarchy only once.  The -fprintf action can be
              used to list the various  matched  items  into  several  different  output
              files.



STANDARDS CONFORMANCE
       For  closest compliance to the POSIX standard, you should set the POSIXLY_CORRECT
       environment variable.  The following options are specified in the POSIX  standard
       (IEEE Std 1003.1, 2003 Edition):


       -H     This option is supported.


       -L     This option is supported.


       -name  This  option is supported, but POSIX conformance depends on the POSIX con‐
              formance of the  system's  fnmatch(3)  library  function.   As  of  findu‐
              tils-4.2.2, shell metacharacters (`*', `?' or `[]' for example) will match
              a leading `.', because IEEE PASC interpretation 126 requires this.    This
              is a change from previous versions of findutils.


       -type  Supported.    POSIX  specifies  `b', `c', `d', `l', `p', `f' and `s'.  GNU
              find also supports `D', representing a Door, where the OS provides these.


       -ok    Supported.  Interpretation of the response is according to the  "yes"  and
              "no"  patterns selected by setting the `LC_MESSAGES' environment variable.
              When the `POSIXLY_CORRECT' environment variable is set, these patterns are
              taken  system's  definition of a positive (yes) or negative (no) response.
              See the system's documentation for nl_langinfo(3), in  particular  YESEXPR
              and NOEXPR.    When `POSIXLY_CORRECT' is not set, the patterns are instead
              taken from find's own message catalogue.


       -newer Supported.  If the file specified is a symbolic link, it is always  deref‐
              erenced.  This is a change from previous behaviour, which used to take the
              relevant time from the symbolic link; see the HISTORY section below.


       -perm  Supported.  If the POSIXLY_CORRECT environment variable is not  set,  some
              mode  arguments  (for  example +a+x) which are not valid in POSIX are sup‐
              ported for backward-compatibility.


       Other predicates
              The predicates -atime, -ctime, -depth, -group, -links,  -mtime,  -nogroup,
              -nouser,  -print,  -prune,  -size,  -user  and  -xdev  `-atime', `-ctime',
              `-depth', `-group', `-links', `-mtime',  `-nogroup',  `-nouser',  `-perm',
              `-print', `-prune', `-size', `-user' and `-xdev', are all supported.


       The POSIX standard specifies parentheses `(', `)', negation `!' and the `and' and
       `or' operators ( -a, -o).

       All other options, predicates, expressions and so forth are extensions beyond the
       POSIX standard.  Many of these extensions are not unique to GNU find, however.

       The POSIX standard requires that find detects loops:

              The  find  utility shall detect infinite loops; that is, entering a previ‐
              ously visited directory that is an ancestor of the last file  encountered.
              When it detects an infinite loop, find shall write a diagnostic message to
              standard error and shall either recover its position in the  hierarchy  or
              terminate.

       GNU  find  complies with these requirements.  The link count of directories which
       contain entries which are hard links to an ancestor will often be lower than they
       otherwise  should  be.   This can mean that GNU find will sometimes optimise away
       the visiting of a subdirectory which is actually a link to  an  ancestor.   Since
       find does not actually enter such a subdirectory, it is allowed to avoid emitting
       a diagnostic message.  Although this behaviour may be somewhat confusing,  it  is
       unlikely  that anybody actually depends on this behaviour.  If the leaf optimisa‐
       tion has been turned off with -noleaf, the directory entry will always  be  exam‐
       ined and the diagnostic message will be issued where it is appropriate.  Symbolic
       links cannot be used to create filesystem cycles as such, but if the -L option or
       the -follow option is in use, a diagnostic message is issued when find encounters
       a loop of symbolic links.  As with loops containing hard links, the leaf  optimi‐
       sation  will  often  mean  that find knows that it doesn't need to call stat() or
       chdir() on the symbolic link, so this diagnostic is frequently not necessary.

       The -d option is supported for compatibility with various BSD  systems,  but  you
       should use the POSIX-compliant option -depth instead.

       The  POSIXLY_CORRECT  environment  variable  does not affect the behaviour of the
       -regex or -iregex tests because those tests aren't specified in the  POSIX  stan‐
       dard.

ENVIRONMENT VARIABLES
       LANG   Provides  a  default value for the internationalization variables that are
              unset or null.


       LC_ALL If set to a non-empty string value, override the values of all  the  other
              internationalization variables.


       LC_COLLATE
              The POSIX standard specifies that this variable affects the pattern match‐
              ing to be used for the  -name  option.    GNU  find  uses  the  fnmatch(3)
              library  function,  and  so support for `LC_COLLATE' depends on the system
              library.    This variable also affects the interpretation of the  response
              to  -ok;  while the `LC_MESSAGES' variable selects the actual pattern used
              to interpret the response  to  -ok,  the  interpretation  of  any  bracket
              expressions in the pattern will be affected by `LC_COLLATE'.


       LC_CTYPE
              This  variable  affects the treatment of character classes used in regular
              expressions and also with the  -name  test,  if  the  system's  fnmatch(3)
              library  function supports this.  This variable also affects the interpre‐
              tation of any character classes in the regular expressions used to  inter‐
              pret the response to the prompt issued by -ok.  The `LC_CTYPE' environment
              variable will also affect which characters are considered to  be  unprint‐
              able when filenames are printed; see the section UNUSUAL FILENAMES.


       LC_MESSAGES
              Determines  the  locale to be used for internationalised messages.  If the
              `POSIXLY_CORRECT' environment variable is set, this  also  determines  the
              interpretation of the response to the prompt made by the -ok action.


       NLSPATH
              Determines the location of the internationalisation message catalogues.


       PATH   Affects the directories which are searched to find the executables invoked
              by -exec, -execdir, -ok and -okdir.


       POSIXLY_CORRECT
              Determines the block size used by -ls and  -fls.   If  POSIXLY_CORRECT  is
              set,  blocks  are  units  of  512 bytes.  Otherwise they are units of 1024
              bytes.

              Setting this variable also turns off warning messages  (that  is,  implies
              -nowarn) by default, because POSIX requires that apart from the output for
              -ok, all messages printed on stderr are diagnostics and must result  in  a
              non-zero exit status.

              When  POSIXLY_CORRECT  is  not  set, -perm +zzz is treated just like -perm
              /zzz if +zzz is not a valid symbolic mode.  When POSIXLY_CORRECT  is  set,
              such constructs are treated as an error.

              When  POSIXLY_CORRECT  is  set, the response to the prompt made by the -ok
              action is interpreted according to  the  system's  message  catalogue,  as
              opposed to according to find's own message translations.


       TZ     Affects  the time zone used for some of the time-related format directives
              of -printf and -fprintf.

BINARIES
       The findutils source distribution contains two different implementations of find.
       The  older  implementation  descends the file system recursively, while the newer
       one uses fts(3).  Both are normally installed.

       If the option --without-fts was passed to configure, the recursive implementation
       is  installed  as  find and the fts-based implementation is installed as ftsfind.
       Otherwise, the fts-based implementation is installed as find  and  the  recursive
       implementation is installed as oldfind.

EXAMPLES
       find /tmp -name core -type f -print | xargs /bin/rm -f

       Find  files named core in or below the directory /tmp and delete them.  Note that
       this will work incorrectly if there are any filenames containing newlines, single
       or double quotes, or spaces.

       find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

       Find  files named core in or below the directory /tmp and delete them, processing
       filenames in such a way that file or directory names containing single or  double
       quotes,  spaces  or  newlines are correctly handled.  The -name test comes before
       the -type test in order to avoid having to call stat(2) on every file.


       find . -type f -exec file '{}' \;

       Runs `file' on every file in or below the current  directory.   Notice  that  the
       braces  are enclosed in single quote marks to protect them from interpretation as
       shell script punctuation.  The semicolon is similarly protected by the use  of  a
       backslash, though single quotes could have been used in that case also.


       find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

       Traverse  the  filesystem  just  once,  listing setuid files and directories into
       /root/suid.txt and large files into /root/big.txt.


       find $HOME -mtime 0

       Search for files in your home directory which have  been  modified  in  the  last
       twenty-four  hours.  This command works this way because the time since each file
       was last modified is divided by 24 hours and any remainder  is  discarded.   That
       means that to match -mtime 0, a file will have to have a modification in the past
       which is less than 24 hours ago.


       find /sbin /usr/sbin -executable \! -readable -print

       Search for files which are executable but not readable.


       find . -perm 664

       Search for files which have read and write permission for their owner, and group,
       but which other users can read but not write to.  Files which meet these criteria
       but have other permissions bits set (for example if someone can execute the file)
       will not be matched.


       find . -perm -664

       Search  for files which have read and write permission for their owner and group,
       and which other users can read, without regard to the presence of any extra  per‐
       mission  bits (for example the executable bit).  This will match a file which has
       mode 0777, for example.


       find . -perm /222

       Search for files which are writable by somebody (their owner, or their group,  or
       anybody else).


       find . -perm /220
       find . -perm /u+w,g+w
       find . -perm /u=w,g=w

       All  three  of these commands do the same thing, but the first one uses the octal
       representation of the file mode, and the other two use the symbolic form.   These
       commands  all  search for files which are writable by either their owner or their
       group.  The files don't have to be writable by both the owner  and  group  to  be
       matched; either will do.


       find . -perm -220
       find . -perm -g+w,u+w

       Both  these  commands  do  the same thing; search for files which are writable by
       both their owner and their group.


       find . -perm -444 -perm /222 ! -perm /111
       find . -perm -a+r -perm /a+w ! -perm /a+x

       These two commands both search for files that are readable for everybody (  -perm
       -444  or -perm -a+r), have at least one write bit set ( -perm /222 or -perm /a+w)
       but are not executable for anybody ( ! -perm /111 and ! -perm /a+x respectively).


       cd /source-dir
       find . -name .snapshot -prune -o \( \! -name *~ -print0 \)|
       cpio -pmd0 /dest-dir

       This command copies the contents of /source-dir to /dest-dir, but omits files and
       directories  named  .snapshot  (and  anything  in  them).  It also omits files or
       directories whose name ends in ~, but not their contents.  The  construct  -prune
       -o  \(  ...  -print0  \)  is  quite common.  The idea here is that the expression
       before -prune matches things which are to be pruned.  However, the -prune  action
       itself  returns  true,  so  the  following -o ensures that the right hand side is
       evaluated only for those directories which didn't get pruned (the contents of the
       pruned  directories are not even visited, so their contents are irrelevant).  The
       expression on the right hand side of the -o is in parentheses only  for  clarity.
       It  emphasises  that  the  -print0 action takes place only for things that didn't
       have -prune applied to them.  Because the default `and' condition  between  tests
       binds  more tightly than -o, this is the default anyway, but the parentheses help
       to show what is going on.


       find repo/ -exec test -d {}/.svn \; -or \
       -exec test -d {}/.git \; -or -exec test -d {}/CVS \; \
       -print -prune

       Given the following directory of projects and their associated SCM administrative
       directories, perform an efficient search for the projects' roots:

       repo/project1/CVS
       repo/gnu/project2/.svn
       repo/gnu/project3/.svn
       repo/gnu/project3/src/.svn
       repo/project4/.git

       In  this  example, -prune prevents unnecessary descent into directories that have
       already been discovered (for example we do not  search  project3/src  because  we
       already  found  project3/.svn),  but  ensures  sibling  directories (project2 and
       project3) are found.


EXIT STATUS
       find exits with status 0 if all files are processed successfully, greater than  0
       if  errors  occur.    This  is  deliberately a very broad description, but if the
       return value is non-zero, you should not rely on the correctness of  the  results
       of find.


SEE ALSO
       locate(1),  locatedb(5),  updatedb(1),  xargs(1), chmod(1), fnmatch(3), regex(7),
       stat(2), lstat(2), ls(1), printf(3), strftime(3), ctime(3),  Finding  Files  (on-
       line in Info, or printed).

HISTORY
       As  of  findutils-4.2.2, shell metacharacters (`*', `?' or `[]' for example) used
       in filename patterns will match a leading `.', because IEEE POSIX  interpretation
       126 requires this.

       As of findutils-4.3.3, -perm /000 now matches all files instead of none.

       Nanosecond-resolution timestamps were implemented in findutils-4.3.3.

       As  of  findutils-4.3.11, the -delete action sets find's exit status to a nonzero
       value when it fails.  However,  find  will  not  exit  immediately.   Previously,
       find's exit status was unaffected by the failure of -delete.

       Feature                Added in   Also occurs in
       -newerXY               4.3.3      BSD
       -D                     4.3.1
       -O                     4.3.1
       -readable              4.3.0
       -writable              4.3.0
       -executable            4.3.0
       -regextype             4.2.24
       -exec ... +            4.2.12     POSIX
       -execdir               4.2.12     BSD
       -okdir                 4.2.12
       -samefile              4.2.11
       -H                     4.2.5      POSIX
       -L                     4.2.5      POSIX
       -P                     4.2.5      BSD
       -delete                4.2.3
       -quit                  4.2.3
       -d                     4.2.3      BSD
       -wholename             4.2.0
       -iwholename            4.2.0
       -ignore_readdir_race   4.2.0
       -fls                   4.0
       -ilname                3.8
       -iname                 3.8
       -ipath                 3.8
       -iregex                3.8

       The  syntax  -perm +MODE does not work as expected in findutils-4.5.11 and it was
       removed in findutils-4.5.12, in favour of -perm /MODE.  The +MODE syntax had been
       deprecated since findutils-4.2.21 which was released in 2005.

NON-BUGS
       $ find . -name *.c -print
       find: paths must precede expression
       Usage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]

       This  happens  because *.c has been expanded by the shell resulting in find actu‐
       ally receiving a command line like this:

       find . -name bigram.c code.c frcode.c locate.c -print

       That command is of course not going to work.  Instead of doing things  this  way,
       you should enclose the pattern in quotes or escape the wildcard:
       $ find . -name '*.c' -print
       $ find . -name \*.c -print


BUGS
       There  are  security  problems  inherent in the behaviour that the POSIX standard
       specifies for find, which therefore cannot be  fixed.   For  example,  the  -exec
       action  is  inherently insecure, and -execdir should be used instead.  Please see
       Finding Files for more information.

       The environment variable LC_COLLATE has no effect on the -ok action.

       The  best  way  to  report  a  bug  is  to  use   the   form   at   http://savan‐
       nah.gnu.org/bugs/?group=findutils.   The reason for this is that you will then be
       able to track progress in fixing the problem.   Other comments about find(1)  and
       about  the  findutils package in general can be sent to the bug-findutils mailing
       list.  To join the list, send email to bug-findutils-request@gnu.org.



                                                                                 FIND(1)
ECHO(1)                               User Commands                              ECHO(1)



NAME
       echo - display a line of text

SYNOPSIS
       echo [SHORT-OPTION]... [STRING]...
       echo LONG-OPTION

DESCRIPTION
       Echo the STRING(s) to standard output.

       -n     do not output the trailing newline

       -e     enable interpretation of backslash escapes

       -E     disable interpretation of backslash escapes (default)

       --help display this help and exit

       --version
              output version information and exit

       If -e is in effect, the following sequences are recognized:

       \\     backslash

       \a     alert (BEL)

       \b     backspace

       \c     produce no further output

       \e     escape

       \f     form feed

       \n     new line

       \r     carriage return

       \t     horizontal tab

       \v     vertical tab

       \0NNN  byte with octal value NNN (1 to 3 digits)

       \xHH   byte with hexadecimal value HH (1 to 2 digits)

       NOTE:  your  shell may have its own version of echo, which usually supersedes the
       version described here.  Please refer to your shell's documentation  for  details
       about the options it supports.

       GNU  coreutils  online help: <http://www.gnu.org/software/coreutils/> Report echo
       translation bugs to <http://translationproject.org/team/>

AUTHOR
       Written by Brian Fox and Chet Ramey.

COPYRIGHT
       Copyright © 2013 Free Software Foundation, Inc.  License GPLv3+: GNU GPL  version
       3 or later <http://gnu.org/licenses/gpl.html>.
       This  is  free software: you are free to change and redistribute it.  There is NO
       WARRANTY, to the extent permitted by law.

SEE ALSO
       The full documentation for echo is maintained as a Texinfo manual.  If  the  info
       and echo programs are properly installed at your site, the command

              info coreutils 'echo invocation'

       should give you access to the complete manual.



GNU coreutils 8.22                    November 2020                              ECHO(1)
PRINTF(1)                             User Commands                            PRINTF(1)



NAME
       printf - format and print data

SYNOPSIS
       printf FORMAT [ARGUMENT]...
       printf OPTION

DESCRIPTION
       Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:

       --help display this help and exit

       --version
              output version information and exit

       FORMAT controls the output as in C printf.  Interpreted sequences are:

       \"     double quote

       \\     backslash

       \a     alert (BEL)

       \b     backspace

       \c     produce no further output

       \e     escape

       \f     form feed

       \n     new line

       \r     carriage return

       \t     horizontal tab

       \v     vertical tab

       \NNN   byte with octal value NNN (1 to 3 digits)

       \xHH   byte with hexadecimal value HH (1 to 2 digits)

       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)

       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)

       %%     a single %

       %b     ARGUMENT  as  a  string  with  '\'  escapes interpreted, except that octal
              escapes are of the form \0 or \0NNN

       and all C format specifications ending with one of diouxXfeEgGcs, with  ARGUMENTs
       converted to proper type first.  Variable widths are handled.

       NOTE: your shell may have its own version of printf, which usually supersedes the
       version described here.  Please refer to your shell's documentation  for  details
       about the options it supports.

       GNU coreutils online help: <http://www.gnu.org/software/coreutils/> Report printf
       translation bugs to <http://translationproject.org/team/>

AUTHOR
       Written by David MacKenzie.

COPYRIGHT
       Copyright © 2013 Free Software Foundation, Inc.  License GPLv3+: GNU GPL  version
       3 or later <http://gnu.org/licenses/gpl.html>.
       This  is  free software: you are free to change and redistribute it.  There is NO
       WARRANTY, to the extent permitted by law.

SEE ALSO
       printf(3)

       The full documentation for printf is maintained as a Texinfo manual.  If the info
       and printf programs are properly installed at your site, the command

              info coreutils 'printf invocation'

       should give you access to the complete manual.



GNU coreutils 8.22                    November 2020                            PRINTF(1)
SCANF(3)                        Linux Programmer's Manual                       SCANF(3)



NAME
       scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion

SYNOPSIS
       #include <stdio.h>

       int scanf(const char *format, ...);
       int fscanf(FILE *stream, const char *format, ...);
       int sscanf(const char *str, const char *format, ...);

       #include <stdarg.h>

       int vscanf(const char *format, va_list ap);
       int vsscanf(const char *str, const char *format, va_list ap);
       int vfscanf(FILE *stream, const char *format, va_list ap);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       vscanf(), vsscanf(), vfscanf():
           _XOPEN_SOURCE >= 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L;
           or cc -std=c99

DESCRIPTION
       The  scanf()  family  of  functions  scans input according to format as described
       below.  This format may contain conversion specifications; the results from  such
       conversions,  if any, are stored in the locations pointed to by the pointer argu‐
       ments that follow format.  Each pointer argument must be of a type that is appro‐
       priate for the value returned by the corresponding conversion specification.

       If  the  number  of  conversion  specifications  in  format exceeds the number of
       pointer arguments, the results are undefined.  If the number of pointer arguments
       exceeds  the  number  of conversion specifications, then the excess pointer argu‐
       ments are evaluated, but are otherwise ignored.

       The scanf() function reads input from the standard input stream  stdin,  fscanf()
       reads input from the stream pointer stream, and sscanf() reads its input from the
       character string pointed to by str.

       The vfscanf() function is analogous to  vfprintf(3)  and  reads  input  from  the
       stream  pointer stream using a variable argument list of pointers (see stdarg(3).
       The vscanf() function scans a variable argument list from the standard input  and
       the  vsscanf()  function  scans  it  from  a  string;  these are analogous to the
       vprintf(3) and vsprintf(3) functions respectively.

       The format string consists of a sequence of  directives  which  describe  how  to
       process the sequence of input characters.  If processing of a directive fails, no
       further input is read, and scanf() returns.  A "failure" can  be  either  of  the
       following:  input  failure,  meaning  that  input characters were unavailable, or
       matching failure, meaning that the input was inappropriate (see below).

       A directive is one of the following:

       ·      A sequence of white-space characters (space, tab, newline, etc.; see  iss‐
              pace(3)).   This  directive  matches  any amount of white space, including
              none, in the input.

       ·      An ordinary character (i.e., one other than white  space  or  '%').   This
              character must exactly match the next character of input.

       ·      A  conversion  specification, which commences with a '%' (percent) charac‐
              ter.  A sequence of characters from the input is  converted  according  to
              this  specification, and the result is placed in the corresponding pointer
              argument.  If the next item of input does not match the conversion  speci‐
              fication, the conversion fails—this is a matching failure.

       Each  conversion  specification in format begins with either the character '%' or
       the character sequence "%n$" (see below for the distinction) followed by:

       ·      An optional '*' assignment-suppression character: scanf() reads  input  as
              directed by the conversion specification, but discards the input.  No cor‐
              responding pointer argument is required, and  this  specification  is  not
              included in the count of successful assignments returned by scanf().

       ·      An  optional 'm' character.  This is used with string conversions (%s, %c,
              %[), and relieves the caller of the need to allocate a corresponding  buf‐
              fer  to  hold the input: instead, scanf() allocates a buffer of sufficient
              size, and assigns the address of this buffer to the corresponding  pointer
              argument,  which  should  be a pointer to a char * variable (this variable
              does not need to be initialized before the call).  The caller should  sub‐
              sequently free(3) this buffer when it is no longer required.

       ·      An  optional  decimal  integer  which  specifies  the maximum field width.
              Reading of characters stops either when this maximum is reached or when  a
              nonmatching character is found, whichever happens first.  Most conversions
              discard initial white space characters (the exceptions are  noted  below),
              and these discarded characters don't count toward the maximum field width.
              String input conversions store a terminating null byte ('\0') to mark  the
              end  of  the input; the maximum field width does not include this termina‐
              tor.

       ·      An optional type modifier character.  For example, the l type modifier  is
              used with integer conversions such as %d to specify that the corresponding
              pointer argument refers to a long int rather than a pointer to an int.

       ·      A conversion specifier that specifies the type of input conversion  to  be
              performed.

       The  conversion  specifications in format are of two forms, either beginning with
       '%' or beginning with "%n$".  The two forms should not be mixed in the same  for‐
       mat  string,  except that a string containing "%n$" specifications can include %%
       and %*.  If format contains '%' specifications then  these  correspond  in  order
       with  successive  pointer  arguments.   In  the "%n$" form (which is specified in
       POSIX.1-2001, but not C99), n is a decimal integer that specifies that  the  con‐
       verted  input  should  be  placed in the location referred to by the n-th pointer
       argument following format.

   Conversions
       The following type modifier characters can appear in a conversion specification:

       h      Indicates that the conversion will be one of d, i, o, u, x, X,  or  n  and
              the next pointer is a pointer to a short int or unsigned short int (rather
              than int).

       hh     As for h, but the next pointer is a pointer to a signed char  or  unsigned
              char.

       j      As for h, but the next pointer is a pointer to an intmax_t or a uintmax_t.
              This modifier was introduced in C99.

       l      Indicates either that the conversion will be one of d, i, o, u, x, X, or n
              and  the  next  pointer  is  a  pointer to a long int or unsigned long int
              (rather than int), or that the conversion will be one of e, f,  or  g  and
              the  next  pointer is a pointer to double (rather than float).  Specifying
              two l characters is equivalent to L.  If used with %c  or  %s  the  corre‐
              sponding parameter is considered as a pointer to a wide character or wide-
              character string respectively.

       L      Indicates that the conversion will be either e,  f,  or  g  and  the  next
              pointer  is a pointer to long double or the conversion will be d, i, o, u,
              or x and the next pointer is a pointer to long long.

       q      equivalent to L.  This specifier does not exist in ANSI C.

       t      As for h, but the next pointer is a pointer to a ptrdiff_t.  This modifier
              was introduced in C99.

       z      As  for  h,  but the next pointer is a pointer to a size_t.  This modifier
              was introduced in C99.

       The following conversion specifiers are available:

       %      Matches a literal '%'.  That is, %% in the format string matches a  single
              input '%' character.  No conversion is done (but initial white space char‐
              acters are discarded), and assignment does not occur.

       d      Matches an optionally signed decimal integer; the next pointer must  be  a
              pointer to int.

       D      Equivalent  to  ld;  this  exists only for backward compatibility.  (Note:
              thus only in libc4.  In libc5 and glibc the %D is silently ignored,  caus‐
              ing old programs to fail mysteriously.)

       i      Matches  an  optionally signed integer; the next pointer must be a pointer
              to int.  The integer is read in base 16 if it begins with  0x  or  0X,  in
              base  8  if  it  begins with 0, and in base 10 otherwise.  Only characters
              that correspond to the base are used.

       o      Matches an unsigned octal integer; the next pointer must be a  pointer  to
              unsigned int.

       u      Matches an unsigned decimal integer; the next pointer must be a pointer to
              unsigned int.

       x      Matches an unsigned hexadecimal  integer;  the  next  pointer  must  be  a
              pointer to unsigned int.

       X      Equivalent to x.

       f      Matches  an optionally signed floating-point number; the next pointer must
              be a pointer to float.

       e      Equivalent to f.

       g      Equivalent to f.

       E      Equivalent to f.

       a      (C99) Equivalent to f.

       s      Matches a sequence of non-white-space characters; the next pointer must be
              a  pointer  to  character  array  that  is  long  enough to hold the input
              sequence and the terminating null byte ('\0'), which  is  added  automati‐
              cally.   The  input  string  stops  at white space or at the maximum field
              width, whichever occurs first.

       c      Matches a sequence of characters whose length is specified by the  maximum
              field  width  (default 1); the next pointer must be a pointer to char, and
              there must be enough room for all the characters (no terminating null byte
              is  added).  The usual skip of leading white space is suppressed.  To skip
              white space first, use an explicit space in the format.

       [      Matches a nonempty sequence  of  characters  from  the  specified  set  of
              accepted characters; the next pointer must be a pointer to char, and there
              must be enough room for all the characters in the string, plus a terminat‐
              ing  null byte.  The usual skip of leading white space is suppressed.  The
              string is to be made up of characters in (or not in) a particular set; the
              set  is defined by the characters between the open bracket [ character and
              a close bracket ] character.  The set excludes  those  characters  if  the
              first  character after the open bracket is a circumflex (^).  To include a
              close bracket in the set, make it  the  first  character  after  the  open
              bracket  or  the  circumflex;  any  other  position will end the set.  The
              hyphen character - is also special; when placed between two other  charac‐
              ters, it adds all intervening characters to the set.  To include a hyphen,
              make it the last character before the final close bracket.  For  instance,
              [^]0-9-]  means  the  set  "everything  except close bracket, zero through
              nine, and hyphen".  The string ends with the appearance of a character not
              in the (or, with a circumflex, in) set or when the field width runs out.

       p      Matches  a  pointer value (as printed by %p in printf(3); the next pointer
              must be a pointer to a pointer to void.

       n      Nothing is expected; instead, the number of characters consumed  thus  far
              from the input is stored through the next pointer, which must be a pointer
              to int.  This is not a conversion, although it can be suppressed with  the
              *  assignment-suppression character.  The C standard says: "Execution of a
              %n directive does not increment the assignment count returned at the  com‐
              pletion of execution" but the Corrigendum seems to contradict this.  Prob‐
              ably it is wise not to make any assumptions on the effect  of  %n  conver‐
              sions on the return value.

RETURN VALUE
       These  functions  return  the  number  of  input  items  successfully matched and
       assigned, which can be fewer than provided for, or even zero in the event  of  an
       early matching failure.

       The  value EOF is returned if the end of input is reached before either the first
       successful conversion or a matching failure occurs.  EOF is also  returned  if  a
       read  error  occurs,  in  which case the error indicator for the stream (see fer‐
       ror(3)) is set, and errno is set indicate the error.

ERRORS
       EAGAIN The file descriptor underlying stream is marked nonblocking, and the  read
              operation would block.

       EBADF  The file descriptor underlying stream is invalid, or not open for reading.

       EILSEQ Input byte sequence does not form a valid character.

       EINTR  The read operation was interrupted by a signal; see signal(7).

       EINVAL Not enough arguments; or format is NULL.

       ENOMEM Out of memory.

       ERANGE The  result  of  an  integer  conversion would exceed the size that can be
              stored in the corresponding integer type.

CONFORMING TO
       The functions fscanf(),  scanf(),  and  sscanf()  conform  to  C89  and  C99  and
       POSIX.1-2001.  These standards do not specify the ERANGE error.

       The  q specifier is the 4.4BSD notation for long long, while ll or the usage of L
       in integer conversions is the GNU notation.

       The Linux version of these functions is based on the GNU libio library.   Take  a
       look  at  the  info  documentation  of  GNU  libc (glibc-1.08) for a more concise
       description.

NOTES
       The GNU C library supported the dynamic allocation  conversion  specifier  (as  a
       nonstandard  extension) via the a character.  This feature seems to be present at
       least as far back as glibc 2.0.

       It is not available  if  the  program  is  compiled  with  gcc  -std=c99  or  gcc
       -D_ISOC99_SOURCE  (unless  _GNU_SOURCE is also specified), in which case the a is
       interpreted as a specifier for floating-point numbers (see above).

       Since version 2.7, glibc also provides the m modifier for the same purpose as the
       a modifier.  The m modifier has the following advantages:

       * It may also be applied to %c conversion specifiers (e.g., %3mc).

       * It  avoids ambiguity with respect to the %a floating-point conversion specifier
         (and is unaffected by gcc -std=c99 etc.)

       * It is specified in the POSIX.1-2008 standard.

BUGS
       All functions are fully C89 conformant, but provide the additional  specifiers  q
       and  a  as  well as an additional behavior of the L and l specifiers.  The latter
       may be considered to be a bug, as it changes the behavior of  specifiers  defined
       in C89.

       Some combinations of the type modifiers and conversion specifiers defined by ANSI
       C do not make sense (e.g., %Ld).  While they may have a well-defined behavior  on
       Linux,  this  need  not to be so on other architectures.  Therefore it usually is
       better to use modifiers that are not defined by ANSI C at all,  that  is,  use  q
       instead of L in combination with d, i, o, u, x, and X conversions or ll.

       The  usage  of q is not the same as on 4.4BSD, as it may be used in float conver‐
       sions equivalently to L.

EXAMPLE
       To use the dynamic allocation conversion specifier, specify m as a  length  modi‐
       fier (thus %ms or %m[range]).  The caller must free(3) the returned string, as in
       the following example:

           char *p;
           int n;

           errno = 0;
           n = scanf("%m[a-z]", &p);
           if (n == 1) {
               printf("read: %s\n", p);
               free(p);
           } else if (errno != 0) {
               perror("scanf");
           } else {
               fprintf(stderr, "No matching characters\n");
           }

       As shown in the above example, it is  necessary  to  call  free(3)  only  if  the
       scanf() call successfully read a string.

SEE ALSO
       getc(3), printf(3), setlocale(3), strtod(3), strtol(3), strtoul(3)

COLOPHON
       This  page is part of release 3.53 of the Linux man-pages project.  A description
       of  the  project,  and  information  about  reporting  bugs,  can  be  found   at
       http://www.kernel.org/doc/man-pages/.



GNU                                    2013-01-30                               SCANF(3)
SU(1)                                 User Commands                                SU(1)



NAME
       su - run a command with substitute user and group ID

SYNOPSIS
       su [options...] [-] [user [args...]]

DESCRIPTION
       su allows to run commands with substitute user and group ID.

       When  called  without  arguments  su  defaults to running an interactive shell as
       root.

       For backward compatibility su defaults to not change the current directory and to
       only  set  the environment variables HOME and SHELL (plus USER and LOGNAME if the
       target user is not root).  It is recommended to always  use  the  --login  option
       (instead it's shortcut -) to avoid side effects caused by mixing environments.

       This  version  of su uses PAM for authentication, account and session management.
       Some configuration options found in other su implementations such as e.g. support
       of a wheel group have to be configured via PAM.

OPTIONS
       -c command, --command=command
              Pass command to the shell with the -c option.

       --session-command=command
              Same as -c but do not create a new session (discouraged).

       -f, --fast
              Pass  -f  to  the  shell  which  may or may not be useful depending on the
              shell.

       -g, --group=group
              specify the primary group, this option is allowed for root user only

       -G, --supp-group=group
              Specify a supplemental group.  This option is available to the  root  user
              only.   The  first specified supplementary group is also used as a primary
              group if the option --group is unspecified.

       -, -l, --login
              Starts the shell as login shell with an  environment  similar  to  a  real
              login:

                 o      clears all environment variables except for TERM

                 o      initializes  the  environment  variables HOME, SHELL, USER, LOG‐
                        NAME, PATH

                 o      changes to the target user's home directory

                 o      sets argv[0] of the shell to '-' in order to make  the  shell  a
                        login shell

       -m, -p, --preserve-environment
              Preserves  the  whole  environment,  ie does not set HOME, SHELL, USER nor
              LOGNAME.  The option is ignored if the option --login is specified.

       -s SHELL, --shell=SHELL
              Runs the specified shell instead of the default.   The  shell  to  run  is
              selected according to the following rules in order:

                 o      the shell specified with --shell

                 o      The  shell  specified  in  the environment variable SHELL if the
                        --preserve-environment option is used.

                 o      the shell listed in the passwd entry of the target user

                 o      /bin/sh

              If the target user has a restricted shell (i.e. not listed in /etc/shells)
              the  --shell option and the SHELL environment variables are ignored unless
              the calling user is root.

       --help Display help text and exit.

       --version
              Display version information and exit.

CONFIG FILES
       su reads the /etc/default/su and /etc/login.defs configuration files.   The  fol‐
       lowing configuration items are relevant for su(1):

       FAIL_DELAY (number)
           Delay  in  seconds  in case of authentication failure.  Number must be a non-
           negative integer.

       ENV_PATH (string)
           Defines the PATH environment variable for a regular user.  The default  value
           is /usr/local/bin:/bin:/usr/bin.

       ENV_ROOTPATH (string)
       ENV_SUPATH (string)
           Defines  the  PATH  environment  variable  for  root.  The  default  value is
           /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin.

       ALWAYS_SET_PATH (boolean)
           If set to yes and --login and --preserve-environment were  not  specified  su
           initializes PATH.

EXIT STATUS
       su  normally  returns the exit status of the command it executed.  If the command
       was killed by a signal, su returns the number of the signal plus 128.

       Exit status generated by su itself:

                 1      Generic error before executing the requested command

                 126    The requested command could not be executed

                 127    The requested command could was not found

FILES
       /etc/pam.d/su    default PAM configuration file
       /etc/pam.d/su-l  PAM configuration file if --login is specified
       /etc/default/su  command specific logindef config file
       /etc/login.defs  global logindef config file

SEE ALSO
       runuser(8), pam(8), shells(5), login.defs(5)

AUTHOR
       Derived from coreutils' su which  was  based  on  an  implementation  from  David
       MacKenzie.

AVAILABILITY
       The  su  command  is  part  of the util-linux package and is available from Linux
       Kernel Archive ⟨ftp://ftp.kernel.org/pub/linux/utils/util-linux/⟩.



util-linux                              June 2012                                  SU(1)
